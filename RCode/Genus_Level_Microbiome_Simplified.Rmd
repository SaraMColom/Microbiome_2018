---
title: "RhizMicrobiome_GenusLevel"
author: "Sara Colom"
date: "2/8/2020"
output: 
  html_document:
    toc: true
    toc_float: true
    highlight: tango
    code_folding: hide
    self_contained: yes 
---


## Sample sizes

### Table sample number by species and treatment


| Species          | Treatment       | N      |
|--------------    |-------------    |----    |
| I. purpurea      | Alone           | 27     |
| I. purpurea      | Competition     | 78     |
| I. hederacea     | Competition     | 78     |


### Table number of maternal line per species

| Species          | Number of ML     |
|--------------    |--------------    |
| I. purpurea      |      10          |
| I. hederacea     |       5          |



### Load Libraries
```{r load_libs, include=T,warning=F,comment=F,message=F}
library(phyloseq)
library(ggplot2)
library(ape)
library(vegan)
library(plyr)
library(dplyr)
library(scales)
library(grid)
library(reshape2)
library(DESeq2)
library(pegas)
library(pgirmess)
library(multcomp)
library(multcompView)
library(ggpubr)
library(ggcorrplot)
library(RColorBrewer)
library(plotly)
library(ggthemes)
library(corrplot)
library(Hmisc)
library(emmeans)
library(lmerTest)


source("~/Google Drive File Stream/My Drive/IDM_Experiments-master/miSeq.R")

# Aesthetics
Tx<-theme(axis.text.y = element_text(size=20),
          axis.title.y = element_text(size=20))+
          theme(axis.text.x = element_text(vjust = 1, hjust=1,angle=0,size=20),
          axis.title.x = element_text(angle=0,size=20),
          plot.title=element_text(size=25,hjust=0))

# Margins
Margin<-theme(
  panel.background = element_rect(fill = "white"),
  plot.margin = margin(2, 2, 2, 2, "cm"),
  plot.background = element_rect(
    fill = "white",
    colour = "black",
    size = 1
  )
)

# Aesthetics
Tx2<-theme(axis.text.y = element_text(size=20),
          axis.title.y = element_text(size=25))+
          theme(axis.text.x = element_text(vjust = 1, hjust=1,size=25),
          axis.title.x = element_text(size=25),
          plot.title=element_text(size=25,hjust=0))

GoldGrey=c("#F1CE63","#79706E")
GreenBlue=c("#59A14F","#4E79A7")

```



## Sequence data analysis
```{r Import Data,warning=F,comment=F,message=F}
### loading mothur output with FWDB+silva taxonomy and sample metadata. 
### Experiments run in 

# Read in mothur output (NOTE you can download mothur output data HERE: https://drive.google.com/drive/folders/1u_KjbdsIcwLEA_Yh4MCYrexvj0YWQrxb?usp=sharing)

setwd("/Volumes/GoogleDrive/My Drive/Baucom Lab /Chapter3MicrobiomeMothur/Subset_Mothur_Output/")

sharedfile <- "stability.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.opti_mcc.shared"
taxfile <- "stability.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.opti_mcc.0.03.cons.taxonomy"

mothurdata <- import_mothur(mothur_shared_file = sharedfile,mothur_constaxonomy_file = taxfile)


setwd("/Volumes/GoogleDrive/My Drive/Baucom Lab /Chapter3MicrobiomeMothur/Microbiome_2018/DataSets/MothurOutput_Mock_Microbiome/Microbiome_Output")

sampledata= read.csv('MetaDataTest.csv')

SAMPLE=sampledata
row.names(SAMPLE)=SAMPLE$Sample_ID

SAMPLE=subset(SAMPLE,SAMPLE$TRT=="Alone"|SAMPLE$TRT=="Inter")
SAMPLE=sample_data(SAMPLE)

### create phyloseq object
physeq.all = merge_phyloseq(mothurdata, SAMPLE) # Modified version worked


### We need to change the taxonomy names: when using the fwdb taxonomy we need to add different headers after removing the last column, which contains no information except for 1 Verrucomicrobia taxon

#   tax_table(physeq.all) <- tax_table(physeq.all)[,-7] # this removes the final column
colnames(tax_table(physeq.all))<-c("Kingdom","Phylum","Class","Order","Family","Genus")


#   tax_table(physeq.all) <-cbind(tax_table(physeq.all),row.names(tax_table(physeq.all)))

### removing non-bacterial reads (was already done in mothur, but just to be safe after merging taxonomies)
#   physeq.all <- subset_taxa(physeq.all, Kingdom == "Bacteria")

```

```{r, aggregate data by genus}

## Aggregate at the genus level, then saving ea componant externally to reload and save time.

        # physeq_genus <- physeq.all %>%
         #tax_glom(taxrank = "Genus") 

        # otu=data.frame(otu_table(physeq_genus))
        
        # meta=data.frame(sample_data(physeq_genus))
        # tax=data.frame(tax_table(physeq_genus))
        
        # write.csv(x = otu,file = "otu_table.csv",row.names = TRUE)
        # write.csv(x = tax,file = "tax_table.csv")# 
        # write.csv(x = meta,file = "sample_table.csv",row.names = F)


otu=read.csv("~/Google Drive File Stream/My Drive/Baucom Lab /Chapter3MicrobiomeMothur/Microbiome_2018/DataSets/MothurOutput_Mock_Microbiome/Microbiome_Output/otu_table.csv",row.names = 1)

colnames(otu)=gsub('X',"",colnames(otu))

otu=otu_table(otu,taxa_are_rows = TRUE)


tax=read.csv('~/Google Drive File Stream/My Drive/Baucom Lab /Chapter3MicrobiomeMothur/Microbiome_2018/DataSets/MothurOutput_Mock_Microbiome/Microbiome_Output/tax_table.csv',row.names=1)
taxRows=row.names(tax)
taxCols=colnames(tax)
tax=tax_table(as.matrix(tax))

#row.names(tax)=taxRows
#colnames(tax)=taxCols


meta=read.csv('~/Google Drive File Stream/My Drive/Baucom Lab /Chapter3MicrobiomeMothur/Microbiome_2018/DataSets/MothurOutput_Mock_Microbiome/Microbiome_Output/MetaDataTest.csv')
namesKeep<-colnames(otu)

row.names(meta)=meta$Sample_ID

meta=meta[which(meta$Sample_ID%in%namesKeep),]
meta=sample_data(meta)
   
physeq_genus=merge_phyloseq(otu,tax,meta)

```



```{r Proteobacteria phylum change to class,warning=F,comment=F,message=F}

setwd("~/Google Drive File Stream/My Drive/Baucom Lab /Chapter3MicrobiomeMothur/Microbiome_2018/DataSets/MothurOutput_Mock_Microbiome/Microbiome_Output")

### ADD THE PROTEOBACTERIA CLASSES TO THE PHYLA NAME FIELD IN PHYLOSEQ OBJECT TAXONOMY 

phy <- data.frame(tax_table(physeq_genus))
Phylum <- as.character(phy$Phylum)
Class <- as.character(phy$Class)
for  (i in 1:length(Phylum)){ 
  if (Phylum[i] == "Proteobacteria"){
    if (Class[i] == "unclassified"){
      Phylum[i] <- Phylum[i]       
    } else {
      Phylum[i] <- Class[i]
    }
  } 
}


Phylum<-as.character(phy$Phylum)
Class=as.character(phy$Class)
phy$Phylum=Phylum
t <- tax_table(as.matrix(phy))

```


```{r read in phylum data, include=FALSE,warning=F,comment=F,message=F}
SAMPLE=sample_data(physeq_genus)
SAMPLE$Species=ifelse(grepl("Ip",SAMPLE$ML),"Ip","Ihed")
physeq.all2 = merge_phyloseq(physeq_genus, SAMPLE) 
```

## Sequence depth and pruning

```{r data scaling}
physeq=(physeq.all2)
physeq <- prune_taxa(taxa_sums(physeq) > 0, physeq) # Remove taxa with no counts

#check number of reads in each sample, differences in count are in part due differet numbers of chlorophyl reads depending on time of experiment

# Make a data frame with a column for the read counts of each sample
sample_sum_df <- data.frame(sum = sample_sums(physeq))

# Histogram of sample read counts
ggplot(sample_sum_df, aes(x = sum)) + 
  geom_histogram(color = "black", fill = "#59A14F", binwidth = 2500) +
  ggtitle("Distribution of sample sequencing depth") + 
  xlab("Read counts") +
  theme(axis.title.y = element_blank())+
  theme_classic()


# Scales reads to smallest library size 
source("https://raw.githubusercontent.com/michberr/MicrobeMiseq/master/R/miseqR.R")
#physeq.scale <- scale_reads(physeq, min(sample_sums(physeq)))

##### Normalization #######

# Scales reads by 
# 1) taking proportions,
# 2) multiplying by a given library size of n
# 3) rounding down
physeq1=prune_samples(sample_sums(physeq) >20000, physeq)
sample_sum_df1 <- data.frame(sum = sample_sums(physeq1))

# Histogram of sample read counts
ggplot(sample_sum_df1, aes(x = sum)) + 
  geom_histogram(color = "black", fill = "#59A14F", binwidth = 2500) +
  ggtitle("Distribution of sample sequencing depth after pruning") + 
  xlab("Read counts") +
  theme(axis.title.y = element_blank())+
  theme_classic()


n=min(sample_sums(physeq1))
  physeq.scale <-
    transform_sample_counts(physeq1, function(x) {
      (n * x/sum(x))  # Transform to rel. abundance
    })
physeq.scale <- prune_taxa(taxa_sums(physeq.scale) > 0, physeq.scale)


physeq1

```

```{r PCoA Treatment and Species comparisoin Bray Curtis Estimate,warning=F,comment=F,message=F}
# Betadiv pcoa Bray-Curtis DNA only 
physeq.pcoa <-
  ordinate(
    physeq = physeq.scale,
    method = "PCoA",
    distance = "bray"
  )

physeq.pcoa.vectors <- data.frame(physeq.pcoa$vectors[, 1:4])
physeq.pcoa.vectors$Duplicates <- row.names(physeq.pcoa.vectors)
SampData=data.frame(sample_data(physeq))
colnames(SampData)[1]="Duplicates"

SampData=subset(SampData,SampData$TRT=="Inter"|SampData$TRT=="Alone")

physeq.pcoa.df <- droplevels(merge(physeq.pcoa.vectors,SampData,by="Duplicates"))
bray_values <- physeq.pcoa$values
bray_rel_eigens <- bray_values$Relative_eig
bray_rel_eigen1 <- bray_rel_eigens[1]
bray_rel_eigen1_percent <- round(bray_rel_eigen1 * 100, digits = 1)
bray_rel_eigen2 <- bray_rel_eigens[2]
bray_rel_eigen2_percent <- round(bray_rel_eigen2 * 100, digits = 1)
bray_rel_eigen3 <- bray_rel_eigens[3]
bray_rel_eigen3_percent <- round(bray_rel_eigen3 * 100, digits = 1)
bray_rel_eigen4 <- bray_rel_eigens[4]
bray_rel_eigen4_percent <- round(bray_rel_eigen4 * 100, digits = 1)
bray_rel_eigen5 <- bray_rel_eigens[5]
bray_rel_eigen5_percent <- round(bray_rel_eigen5 * 100, digits = 1)
bray_axis1 <- paste("PCoA 1:",bray_rel_eigen1_percent,"%")
bray_axis2 <- paste("PCoA 2:",bray_rel_eigen2_percent,"%")
bray_axis3 <- paste("PCoA 3:",bray_rel_eigen3_percent,"%")
bray_axis4 <- paste("PCoA 4:",bray_rel_eigen4_percent,"%")
PCoA_title <- paste("Bray-Curtis,",ntaxa(physeq.scale),"OTUs")


pcoa_exp_trt <- ggplot(physeq.pcoa.df, aes(Axis.1, Axis.2, color = TRT,fill = TRT)) +
  xlab(bray_axis1) + 
  ylab(bray_axis2) +
  geom_point(alpha=0.9) + 
  theme_classic() +
  scale_fill_manual(values = c("#00B050","grey"),"Treatment", labels = c("Alone", "Competition"))+
  scale_color_manual(values = c("#00B050","grey"),"Treatment", labels = c("Alone", "Competition"))+
  stat_ellipse(geom = "polygon", alpha = 1/6, aes(fill =TRT))+
  Tx+
  theme(axis.text.x = element_text(angle=45),axis.text=element_text(color="black",size=15,vjust = 0.5,hjust=1))
#  scale_fill_discrete(name = "Treatment", labels = c("Alone", "Competition"))+
 # scale_color_discrete(name = "Treatment", labels = c("Alone", "Competition"))



pcoa_exp_trtA <- ggplot(physeq.pcoa.df, aes(Axis.3, Axis.4, color = TRT,fill = TRT)) +
  xlab(bray_axis3) + 
  ylab(bray_axis4) + 
  geom_point(alpha=0.9) + 
  theme_classic() +
  scale_fill_manual(values = GoldGrey,"Treatment", labels = c("Alone", "Competition"))+
  scale_color_manual(values = GoldGrey,"Treatment", labels = c("Alone", "Competition"))+
  stat_ellipse(geom = "polygon", alpha = 1/6, aes(fill =TRT))+
  Tx


pcoa_exp_sp <- ggplot(physeq.pcoa.df, aes(Axis.1, Axis.2, color = Species,fill = Species)) +
  xlab("") + 
  ylab(bray_axis2) +
  geom_point(alpha=0.9) + 
  theme_classic() +
 scale_fill_manual(values = GreenBlue,"Species", labels = c("I. hederacea", "I. purpurea"))+
  scale_color_manual(values = GreenBlue,"Species", labels = c("I. hederacea", "I. purpurea"))+
   stat_ellipse(geom = "polygon", alpha = 1/6, aes(fill =Species))+
  Tx


pcoa_exp_spA <- ggplot(physeq.pcoa.df, aes(Axis.3, Axis.4, color = Species,fill = Species)) +
  xlab("") + 
  ylab(bray_axis4) +
  geom_point(alpha=0.9) + 
  theme_classic()+
  scale_fill_manual(values = GreenBlue,"Species", labels = c("I. hederacea", "I. purpurea"))+
  scale_color_manual(values = GreenBlue,"Species", labels = c("I. hederacea", "I. purpurea"))+
  stat_ellipse(geom = "polygon", alpha = 1/6, aes(fill =Species))+
  Tx

dev.off()
A=ggarrange(pcoa_exp_trt,pcoa_exp_trtA,common.legend = T,labels=c("C","D"),font.label = list(size = 15, color = "black", face =
  "plain"),hjust = -8,vjust=1)
B=ggarrange(pcoa_exp_sp,pcoa_exp_spA,common.legend = T,labels=c("A","B"),font.label = list(size = 15, color = "black", face =
  "plain"),hjust = -8,vjust=1)

MainFig=ggarrange(B,A,nrow=2)

annotate_figure(MainFig,
                top = text_grob(PCoA_title, face = "plain", size = 25,lineheight = 2)
)

```



```{r 3D graphic,warning=F,comment=F,message=F}

physeq.pcoa.df$TrtSp=paste(physeq.pcoa.df$TRT,physeq.pcoa.df$Species,sep="")

p <- plot_ly(physeq.pcoa.df, x = ~Axis.1, y = ~Axis.2, z = ~Axis.3, color = ~TrtSp) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = bray_axis1),
                     yaxis = list(title = bray_axis2),
                     zaxis = list(title = bray_axis3)))


p1 <- plot_ly(physeq.pcoa.df, x = ~Axis.1, y = ~Axis.2, z = ~Axis.4, color = ~Species) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = bray_axis1),
                     yaxis = list(title = bray_axis2),
                     zaxis = list(title = bray_axis4)))

p3 <- plot_ly(physeq.pcoa.df, x = ~Axis.1, y = ~Axis.2, z = ~Axis.4, color = ~Species) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = bray_axis1),
                     yaxis = list(title = bray_axis3),
                     zaxis = list(title = bray_axis4)))

```

```{r adonis experimental data when all data combined,warning=F,comment=F,message=F}
## All experiment, add variable treatment, then species
sampledf <- data.frame(sample_data(physeq.scale))
sampledf=subset(sampledf,sampledf$TRT=="Alone"|sampledf$TRT=="Inter")

## Subsample by species 
physeq.purp=subset_samples(physeq.scale, Species == "Ip")
physeq.hed=subset_samples(physeq.scale, Species != "Ip")

## Subsample within competition
physeq.comp=subset_samples(physeq.scale, TRT=="Inter")

# Calculate bray curtis for experimental samples only
physeq.bray <- phyloseq::distance(physeq = physeq.scale, method = "bray") # acrosss species and treatment
physeq.bray2 <- phyloseq::distance(physeq = physeq.purp, method = "bray") # within Ipurp
physeq.bray2b <- phyloseq::distance(physeq = physeq.hed, method = "bray") # within Ipurp

physeq.bray3 <- phyloseq::distance(physeq = physeq.comp, method = "bray") # within competition

sampledf$Comp=sub(".*\\-","",sampledf$Combos)

# Adonis test for treatment, across species
adonis(physeq.bray ~ TRT, data = sampledf)
b = betadisper(physeq.bray,sampledf$TRT)

p <- permutest(b)
p$tab

# Adonis test for treatment, WITHIN species
adonis(physeq.bray2 ~ TRT+Block, data = sampledf%>%filter(Species=="Ip")) # No treatment effect on bray distances

b = betadisper(physeq.bray,sampledf$TRT)
p <- permutest(b)
p$tab

# Adonis test for treatment, WITHIN species
adonis(physeq.bray2 ~ TRT+Block*ML, data = sampledf%>%filter(Species=="Ip")) # No treatment effect on bray distances

adonis(physeq.bray2b ~ Block*ML, data = sampledf%>%filter(Species!="Ip")) # No treatment effect on bray distances


# Adonis test for species 
set.seed(7L)
adonis(physeq.bray3 ~ Species+Block*ML, data = sampledf%>%filter(TRT=="Inter"))
b = betadisper(physeq.bray3,( sampledf%>%filter(TRT=="Inter"))$Species)
p <- permutest(b)
p$tab

sampledf$Block=as.factor(sampledf$Block)
sampledf$Comp=as.factor(sampledf$Comp)



```


```{r AMOVA}

# # # # # # # # # # # # # # # # # # # # # 
#             ACROSS SAMPLES
amova(physeq.bray ~ TRT, data = sampledf) # Across all samples
amova(physeq.bray ~ Species, data = sampledf) # Across all samples

# # # # # # # # # # # # # # # # # # # # # 
# Subsample for within I. purpurea only
# # # # # # # # # # # # # # # # # # # # # 

physeq.Purp <- subset_samples(physeq.scale, Species == "Ip")
sampledf.Purp<- data.frame(sample_data(physeq.Purp))
# Calculate bray curtis for summer samples only
physeq.Purp.bray <- phyloseq::distance(physeq = physeq.Purp, method = "bray")
amova(physeq.Purp.bray ~ TRT, data = sampledf.Purp) # Across all samples


# # # # # # # # # # # # # # # # # # # # # 
# Subsample for within competition
# # # # # # # # # # # # # # # # # # # # # 

physeq.Comp <- subset_samples(physeq.scale, TRT=="Inter")
sampledf.Comp<- data.frame(sample_data(physeq.Comp))
# Calculate bray curtis for summer samples only
physeq.Comp.bray <- phyloseq::distance(physeq = physeq.Comp, method = "bray")
amova(physeq.Comp.bray ~ Species, data = sampledf.Comp) # marginal species differences

```


## Test for differently abundant OTUs

### Visualize the different groups at the family level
```{r}
# Check for 'core' microbiome members as the phylum level which taxa are present
# at 1 % overall abundance and at least 75% of samples 

PhylumGlom<-tax_glom(physeq.Purp,taxrank="Phylum")
FamGlom<-tax_glom(physeq.Purp,taxrank="Family")
ClassGlom<-tax_glom(physeq.Purp,taxrank="Class")


coreTaxa = filter_taxa(PhylumGlom, function(x) sum(x > 1) > (0.75 * length(x)), TRUE)
coreTaxaFamily = filter_taxa(FamGlom, function(x) sum(x > 1) > (0.75 * length(x)), TRUE)

## Plot at phylum level


physeq1_phylumAlone <- coreTaxa  %>%
  subset_samples(TRT=="Alone")%>%
  transform_sample_counts(function(x) {x/sum(x)} ) %>% # Transform to rel. abundance
  psmelt()      


physeq1_phylumComp <- coreTaxa  %>%
  subset_samples(TRT!="Alone")%>%
  transform_sample_counts(function(x) {x/sum(x)} ) %>% # Transform to rel. abundance
  psmelt()       

physeq1_phylum<-rbind(physeq1_phylumAlone,physeq1_phylumComp)

# Melt to long format
physeq1_phylum=physeq1_phylum[order(physeq1_phylum$Phylum),] 

#colnames(physeq1_phylum)[13]="Phylum"

# Sort data frame alphabetically by phylum
# Set colors for plotting
phylum_colors <- c(
  "#CBD588", "#5F7FC7", "orange","#DA5724", "#508578", "#CD9BCD",
   "#AD6F3B", "#673770","#D14285", "#652926", "#C84248", 
  "#8569D5", "#5E738F","#D1A33D", "#8A7C64", "#599861"
)


#colnames(physeq1_phylum)[which(names(physeq1_phylum)%in%"Rank2")]="Phylum"

# Plot 
ggplot(physeq1_phylum, aes(x = TRT, y = Abundance, fill = Phylum)) + 
  geom_bar(stat = "identity",position='dodge')+
  #scale_fill_manual(values = phylum_colors)+
  theme(axis.title.x = element_blank()) + 
  ylab("Relative Abundance (Phyla > 75 %) \n") +
  ggtitle("Phylum Composition  \n Bacterial Communities by Sampling per Treatment") +
  theme_classic()+
  ylab("Relative Abundance")

```


## Testing if different at the phylum level
```{r}

PhlyaList<-as.list(unique(physeq1_phylum$Phylum))

KrusMicrTest<-function(Microbe){
  Result=kruskal.test(Abundance ~ TRT, data = physeq1_phylum[which(physeq1_phylum$Phylum==Microbe),]) 

ResDf=data.frame("ChiSq"=Result$statistic,"Pval"=Result$p.value,"Phylum"=paste(Microbe))  
  return(ResDf)  
}

AllResults=lapply(PhlyaList,KrusMicrTest)
KruskalRes=do.call('rbind',AllResults)
```


## Family level
```{r}

# Family level
physeq1_FamilyAlone <- coreTaxaFamily  %>%
  subset_samples(TRT=="Alone")%>%
  transform_sample_counts(function(x) {x/sum(x)} ) %>% # Transform to rel. abundance
  psmelt()                                      # Melt to long format

physeq1_FamilyComp <- coreTaxaFamily  %>%
  subset_samples(TRT!="Alone")%>%
  transform_sample_counts(function(x) {x/sum(x)} ) %>% # Transform to rel. abundance
  psmelt()       

physeq1_Family<-rbind(physeq1_FamilyAlone,physeq1_FamilyComp)


FamList<-as.list(unique(physeq1_Family$Family))

KrusMicrTest<-function(Microbe){
  Result=kruskal.test(Abundance ~ TRT, data = physeq1_Family[which(physeq1_Family$Family==Microbe),]) 

ResDf=data.frame("ChiSq"=Result$statistic,"Pval"=Result$p.value,"Family"=paste(Microbe))  
  return(ResDf)  
}

AllResultsFamily=lapply(FamList,KrusMicrTest)
KruskalResFamily=do.call('rbind',AllResultsFamily)

KruskalResFamily%>%filter(Pval<0.055)

# Do false discovery rate for mulitple corrections

KruskalResFamily$AdjPval=p.adjust(KruskalResFamily$Pval, method = "fdr", n = 213)
```


## Alpha diversity

```{r alpha diversity,warning=F,comment=F,message=F}
hist(sample_sums(physeq1))
# Remove sample with less than 20K reads, this looks WAAAY off
# Rarify first
ps.rarefied=rarefy_even_depth(physeq1,rngseed=1,sample.size=min(sample_sums(physeq1)),replace=F)

plot_richness(ps.rarefied,x="TRT",measures=c("Observed","Shannon"))+
  geom_boxplot()+
  theme_classic()

```


## Alpha Diversity

#### Note: Measures of alpha-diversity 

_*Inverse Simpson*_ it is an indication of the richness in a community with uniform evenness that would have the same level of diversity. So while measures such as the Shannon index are somewhat abstract, the inverse of the Simpson index has some biological interpretation. Other advantages of the Simpson-based metrics are that they do not tend to be as affected by sampling effort as the Shannon index.
   
- _*Species richness*_ is simply a count of species, and it does not take into account the abundances of the species or their relative abundance distributions.
   
- _*Simpson's Diversity Index*_ is a measure of diversity which takes into account the number of species present, as well as the relative abundance of each species. As species richness and evenness increase,so diversity increases.



```{r Richness and Inverse Simpson,warning=F,comment=F,message=F}

### I commented out the subsampling to save time. The matrices produced were saved and then reoponed from their tab delmited formats into corresponding matrices.

set.seed(3)

r <- rarefy_even_depth(physeq1, sample.size = n, verbose = FALSE, replace = TRUE)
         
 ## Calculate richness
rich <- as.numeric(as.matrix(estimate_richness(r, measures = "Observed")))

## Calculate Inverse Simpson

simp <- as.numeric(as.matrix(estimate_richness(r, measures = "InvSimpson")))

sim<- as.numeric(as.matrix(estimate_richness(r, measures = "Simpson")))

s <- rarefy_even_depth(physeq1, sample.size = n, verbose = FALSE, replace = TRUE)
shan <- as.numeric(as.matrix(estimate_richness(r, measures = "Shannon")))

InvSimp=simp

```





```{r}
# Create a new dataframe to hold the means and standard deviations of richness estimates
length(rich)

Sample_ID <- sample_names(physeq1)
Block <-sample_data(physeq1)$Block
Species <-sample_data(physeq1)$Species
TRT <-sample_data(physeq1)$TRT
Combos <-sample_data(physeq1)$Combos
ML <-sample_data(physeq1)$ML

alpha=data.frame(Sample_ID,ML,Block,TRT,Species,Combos,rich,InvSimp,sim,shan)

alpha$even=alpha$shan/alpha$rich

# DO VIOLIN PLOT HERE!!!


p=ggplot(alpha%>%filter(TRT=="Inter"), aes(x=Species, y=rich)) +
  geom_violin(trim=FALSE,aes(fill=Species),alpha=0.3)+ 
  geom_dotplot(binaxis='y', stackdir='center', dotsize=1,aes(color=Species,fill=Species))+
  theme_classic()+
  scale_color_brewer(palette = "Paired")+
  scale_fill_brewer(palette = "Paired")+
  ggtitle("Mean Species Richness")


q=ggplot(alpha%>%filter(TRT=="Inter"), aes(x=Species, y=InvSimp)) +
  geom_violin(trim=FALSE,aes(fill=Species),alpha=0.3)+ 
  geom_dotplot(binaxis='y', stackdir='center', dotsize=1,aes(color=Species,fill=Species))+
  theme_classic()+
  scale_color_brewer(palette = "Paired")+
  scale_fill_brewer(palette = "Paired")+
  ggtitle("Mean Species Inverse Simpson")+
  ylab("")


t=ggplot(alpha%>%filter(TRT=="Inter"), aes(x=Species, y=sim)) +
  geom_violin(trim=FALSE,aes(fill=Species),alpha=0.3)+ 
  geom_dotplot(binaxis='y', stackdir='center', dotsize=1,aes(color=Species,fill=Species))+
  theme_classic()+
  scale_color_brewer(palette = "Paired")+
  scale_fill_brewer(palette = "Paired")+
  ggtitle("Mean Simpson")+
  ylab("")

v=ggplot(alpha%>%filter(TRT=="Inter"), aes(x=Species, y=even)) +
  geom_violin(trim=FALSE,aes(fill=Species),alpha=0.3)+ 
  geom_dotplot(binaxis='y', stackdir='center', dotsize=1,aes(color=Species,fill=Species))+
  theme_classic()+
  scale_color_brewer(palette = "Paired")+
  scale_fill_brewer(palette = "Paired")+
  ggtitle("Mean Evenness")+
  ylab("")



ggarrange(p,q,t,v,common.legend=T,ncol=2,nrow=2)



      ### Treatment

pT=ggplot(alpha%>%filter(Species=="Ip"), aes(x=TRT, y=rich)) +
  geom_violin(trim=FALSE,aes(fill=TRT),alpha=0.3)+ 
  geom_dotplot(binaxis='y', stackdir='center', dotsize=1,aes(color=TRT,fill=TRT))+
  theme_classic()+
  scale_color_manual(values=c("#B2DF8A","#fee090"))+
  scale_fill_manual(values=c("#B2DF8A","#fee090"))+
  ggtitle("Mean Treatment Richness")


qT=ggplot(alpha%>%filter(Species=="Ip"), aes(x=TRT, y=InvSimp)) +
  geom_violin(trim=FALSE,aes(fill=TRT),alpha=0.3)+ 
  geom_dotplot(binaxis='y', stackdir='center', dotsize=1,aes(color=TRT,fill=TRT))+
  theme_classic()+
  scale_color_manual(values = c("#B2DF8A","#fee090"))+
  scale_fill_manual(values = c("#B2DF8A","#fee090"))+
  ggtitle("Mean Treatment Inverse Simpson")+
  ylab(" ")

ggarrange(pT,qT,common.legend=T)

```

## Test for differences


```{r ANOVAS on alpha diversities,warning=F,comment=F,message=F}
# first check for normality. To test for normalcy statistically, we can run the Shapiro-Wilk test of normality.

shapiro.test(alpha$rich) # Not normal
shapiro.test(alpha$even) # Normal
shapiro.test(alpha$sim) # Normal

histogram(alpha$rich,xlab="Richness") # Note richness though, not normal, looks close to normal.

histogram(alpha$InvSimp,xlab="Inverse-Simpson")
histogram(alpha$sim,xlab="Simpson")


#   Run the ANOVA and save it as an object

# Test for species within competition
aov.Richness = aov(rich~Species+Block,alpha%>%filter(TRT=="Inter"))
aov.simpsonInv = aov(InvSimp~Species+Block,alpha%>%filter(TRT=="Inter"))
aov.simpson = aov(sim~Species+Block,alpha%>%filter(TRT=="Inter"))
aov.evenness = aov(even~Species+Block,alpha%>%filter(TRT=="Inter"))
aov.shannon = aov(shan~Species+Block,alpha%>%filter(TRT=="Inter"))

#Call for the summary of that ANOVA, which will include P-values
summary(aov.Richness)
summary(aov.simpsonInv)
summary(aov.simpson)
summary(aov.evenness)
summary(aov.shannon)

# No significant differences


# Test for treatment within I. purpurea
alpha.purp<-alpha%>%filter(Species=="Ip")

aov.Richness = lm(rich~TRT+Block,alpha.purp)
aov.simpsonInv = lm(InvSimp~TRT+Block,alpha.purp)
aov.simpson = lm(sim~TRT+Block,alpha.purp)
aov.evenness = lm(even~TRT+Block,alpha.purp)
aov.shannon = lm(shan~TRT+Block,alpha.purp)


#Call for the summary of that ANOVA, which will include P-values
anova(aov.Richness)
anova(aov.simpsonInv)
anova(aov.simpson)
anova(aov.evenness)

# No significant differences


# Model accross species and treatment 
aov.Richness = aov(rich~TRT+Species+Block,alpha)
aov.simpsonInv = aov(InvSimp~TRT+Species+Block,alpha)
aov.simpson = aov(sim~TRT+Species+Block,alpha)
aov.evenness = aov(even~TRT+Species+Block,alpha)
aov.shannon = aov(shan~TRT+Species+Block,alpha)


#Call for the summary of that ANOVA, which will include P-values
anova(aov.Richness)
anova(aov.simpsonInv)
anova(aov.simpson)
anova(aov.evenness)
# summary(aov.shannon)



# Boxplot
ggplot(alpha%>%filter(Species=="Ip"),aes(TRT,rich))+
  geom_boxplot()+
  theme_bw()+
  ylab("Richness")+
  xlab("")+
  scale_x_discrete(labels=c("Alone","Competition"))+
  theme(axis.text.x = element_text(vjust = -1),axis.text=element_text(size=20),axis.title=element_text(size=30),axis.title.x = element_text(vjust=-1))+
  Margin

ggplot(alpha%>%filter(Species=="Ip"),aes(TRT,even))+
  geom_boxplot()+
  theme_bw()+
  ylab("Evenness")+
  xlab("")+
  scale_x_discrete(labels=c("Alone","Competition"))+
  theme(axis.text.x = element_text(vjust = -1),axis.text=element_text(size=20),axis.title=element_text(size=30),axis.title.x = element_text(vjust=-1))+
  Margin

ggplot(alpha%>%filter(Species=="Ip"),aes(TRT,sim))+
  geom_boxplot()+
  theme_bw()+
  ylab("Simpson")+
  xlab("")+
  scale_x_discrete(labels=c("Alone","Competition"))+
  theme(axis.text.x = element_text(vjust = -1),axis.text=element_text(size=20),axis.title=element_text(size=30),axis.title.x = element_text(vjust=-1))+
  Margin

ggplot(alpha%>%filter(Species=="Ip"),aes(TRT,InvSimp))+
  geom_boxplot()+
  theme_bw()+
  ylab("Inverse Simpson")+
  xlab("")+
  scale_x_discrete(labels=c("Alone","Competition"))+
  theme(axis.text.x = element_text(vjust = -1),axis.text=element_text(size=20),axis.title=element_text(size=30),axis.title.x = element_text(vjust=-1))+
  Margin

```

# Linear mixed models
```{r, LMM within species Not Reported}
# Test for treatment within I. purpurea


RichLmm = lmer(rich~TRT+Block+(1|Block:ML),alpha%>%filter(Species=="Ip"))
InvLmm = lmer(InvSimp~TRT+Block+(1|Block:ML),alpha%>%filter(Species=="Ip"))
SimLmm = lmer(sim~TRT+Block+(1|Block:ML),alpha%>%filter(Species=="Ip"))
EvenLmm = lmer(even~TRT+Block+(1|Block:ML),alpha%>%filter(Species=="Ip"))

anova(RichLmm)
ranova(RichLmm)

anova(InvLmm)
ranova(InvLmm)

anova(SimLmm)
ranova(SimLmm)

anova(EvenLmm)
ranova(EvenLmm)


```


## Continous data (root traits, leaf number)
Here, I correlate leaf number to OTUs with at least 5% relative abundance in at least one sample in our data set.

```{r Analyzing leaf data,warning=F,comment=F,message=F}
LeafData<-read.csv("~/Google Drive File Stream/My Drive/Field_2018/Field_2018_Rcode/CharacterDisplacementRootTraits/CleanData/SizeFitData.csv")

LeafData$Sample_ID=paste(LeafData$Position,ifelse(grepl("Ihed",LeafData$ML),"H","P"),sep="")
```


```{r Alpha, more estimates,warning=F,comment=F,message=F}

## Additional estimates of alpha diversity
 # Specify a few:
AlphaExtra=estimate_richness(physeq1, measures=c("Observed", "InvSimpson", "Shannon", "Chao1"))
```


## Preliminary test with roots

```{r Preliminary exam on root linear model}
RootData=read.csv("~/Google Drive File Stream/My Drive/Baucom Lab /Chapter3MicrobiomeMothur/Microbiome_2018/DataSets/MothurOutput_Mock_Microbiome/Microbiome_Output/RootTraits_PCs.csv")

RootAlphaObs=merge(alpha,RootData[c("Sample_ID","PC1","PC2","PC3","PC4")])

SimpPC1=lm(sim~PC1+Species+TRT+Block,RootAlphaObs) 
summary(SimpPC1)

SimpInvPC1=lm(InvSimp~PC1+Species+TRT+Block,RootAlphaObs) 
summary(SimpInvPC1)

RichPC1=lm(rich~PC1+Species+TRT+Block,RootAlphaObs) 
summary(RichPC1)# Significant coefficient

# Adjust p-value for multiple comparisons (1 for each PC used to test)
p.adjust((summary(RichPC1)$coefficients[2,4]), method = "bonferroni", n = 4) # still significant, corrected p-value:
# 0.01158722

EvenPC1=lm(even~PC1+Species+TRT+Block,RootAlphaObs) 
summary(EvenPC1)# Significant coefficient

    # Adjust p-value for multiple comparisons (1 for each PC used to test)
    p.adjust((summary(EvenPC1)$coefficients[2,4]), method = "bonferroni", n = 4) # still significant, corrected p-value:
    # 0.02191386

SimpPC2=lm(sim~PC2+Species+TRT+Block,RootAlphaObs) 
summary(SimpPC2) 

SimpInvPC2=lm(InvSimp~PC2+Species+TRT+Block,RootAlphaObs)
summary(SimpInvPC2) 

RichPC2=lm(rich~PC2+Species+TRT+Block,RootAlphaObs) 
summary(RichPC2) # Significant coefficient

    # Adjust p-value for multiple comparisons (1 for each PC used to test)
    p.adjust((summary(RichPC2)$coefficients[2,4]), method = "bonferroni", n = 4) # still significant, corrected p-value:
    # 0.04698757


EvenPC2=lm(even~PC2+Species+TRT+Block,RootAlphaObs) 
summary(EvenPC2) # Significant coefficient

    # Adjust p-value for multiple comparisons (1 for each PC used to test)
    p.adjust((summary(EvenPC2)$coefficients[2,4]), method = "bonferroni", n = 4) # Not significant, corrected p-value:
    # 0.1492003

### PC3
SimpPC3=lm(sim~PC3+Species+TRT+Block,RootAlphaObs) 
summary(SimpPC3) 

SimpInvPC3=lm(InvSimp~PC3+Species+TRT+Block,RootAlphaObs) 
summary(SimpInvPC3) 

RichPC3=lm(rich~PC3+Species+TRT+Block,RootAlphaObs) 
summary(RichPC3)

EvenPC3=lm(even~PC3+Species+TRT+Block,RootAlphaObs) 
summary(EvenPC3)

### PC4
SimpPC4=lm(sim~PC4+Species+TRT+Block,RootAlphaObs) 
summary(SimpPC4) # Significant coefficient

    # Adjust p-value for multiple comparisons (1 for each PC used to test)
    p.adjust((summary(SimpPC4)$coefficients[2,4]), method = "bonferroni", n = 4) # still significant, corrected p-value:
    # 0.00834712

SimpInvPC4=lm(InvSimp~PC4+Species+TRT+Block,RootAlphaObs) 
summary(SimpInvPC4)  # Significant coefficient
  
  # Adjust p-value for multiple comparisons (1 for each PC used to test)
      p.adjust((summary(SimpInvPC4)$coefficients[2,4]), method = "bonferroni", n = 4) # marginally significant, corrected p-value:
      # 0.07073862

RichPC4=lm(rich~PC4+Species+TRT+Block,RootAlphaObs) 
summary(RichPC4)

EvenPC4=lm(even~PC4+Species+TRT+Block,RootAlphaObs) 
summary(EvenPC4)
```

## Within species (root traits and alphadiv)


```{r Preliminary exam on roots within species}

library(multcomp)

#summary(glht(SimpInvPC1, mcp(rank="Tukey")))

#################################################################
##################### SUBSET for I.purpurea #####################
#################################################################


RootAlphaPurp=droplevels(RootAlphaObs%>%filter(Species=="Ip"))
RootAlphaPurp$Comp=sub(".*\\-","",RootAlphaPurp$Combos)

SimpPC1=lm(sim~TRT+Block+PC1,RootAlphaPurp) 
summary(SimpPC1)
anova(SimpPC1) # Significant Competitor effect
car::Anova(SimpPC1)

SimpInvPC1=lm(InvSimp~PC1+Comp+TRT+Block,RootAlphaPurp) 
anova(SimpInvPC1) # Significant PC1 effect only, no Comp or Comp by PC1 effect


RichPC1=lm(rich~TRT+Block+PC1,RootAlphaPurp) 
anova(RichPC1) 
summary(RichPC1 )


car::Anova(lm(sim~TRT+Block+PC2*TRT,RootAlphaPurp),type="III") # No interaction effect

SimpPC2=lm(sim~TRT+Block+PC2,RootAlphaPurp) 
summary(SimpPC2) # NS



# ANCOVA

car::Anova(lm(sim~TRT+Block+PC2*TRT,RootAlphaPurp),type="III") # No interaction effect



SimpInvPC2=lm(InvSimp~TRT+Block+PC2+Block,RootAlphaPurp) 
anova(SimpInvPC2) # NS

# ANCOVA
car::Anova(lm(InvSimp~TRT+Block+PC2*TRT,RootAlphaPurp),type="III") # No interaction effect


RichPC2=lm(rich~TRT+Block+PC2,RootAlphaPurp) 
anova(RichPC2) # Significant coefficient SUPER small effect size


EvenPC2=lm(even~TRT+Block+PC2,RootAlphaPurp) 
anova(EvenPC2) # Significant mean Evenness effect--should Check this out it is suspect


### PC3
SimpPC3=lm(sim~TRT+Block+PC3,RootAlphaPurp) 
anova(SimpPC3) # NS


SimpInvPC3=lm(InvSimp~TRT+Block+PC3,RootAlphaPurp) 
anova(SimpInvPC3) # NS

RichPC3=lm(rich~TRT+Block+PC3,RootAlphaPurp) 
anova(RichPC3)

EvenPC3=lm(even~TRT+Block+PC3,RootAlphaPurp) 
summary(EvenPC3)
anova(EvenPC3)


### PC4
SimpPC4=lm(sim~TRT+Block+PC4,RootAlphaPurp%>%filter(sim>0.94)) 
summary(SimpPC4) # Significant
anova(SimpPC4)


SimpInvPC4=lm(InvSimp~TRT+Block+PC4,RootAlphaPurp) 
summary(SimpInvPC4)  # Marginal InvSimp significant
anova(SimpInvPC4)

RichPC4=lm(rich~TRT+Block+PC4,RootAlphaPurp) 
summary(RichPC4) # NS
anova(RichPC4)

EvenPC4=lm(even~TRT+Block+PC4,RootAlphaPurp) 
summary(EvenPC4)
anova(EvenPC4)


```

## Plotting significant linear associations
```{r n}

# Richness and root architecture
P2.rich=ggplot()+
  geom_point(data=RootAlphaPurp,aes(PC2,rich),alpha=0.5,size=5)+
  geom_smooth(data=RootAlphaPurp,method="lm",aes(PC2,rich),fullrange=TRUE)+
  theme_classic()+
  ylab("Richness")+
  xlab("")+
  Tx2
#+ 
  #annotate("text", x = -1, y = 500, label = "paste(italic(R) ^ 2, \" = 0.15\")", parse = TRUE,hjust=0,size=5)+ 
 # annotate("text", x = -1, y = 490, label = "paste(italic(B), \" = -4.65 +/-1.81\")", parse = TRUE,hjust=0,size=5)+
 # annotate("text", x = -1, y = 480, label = "paste(italic(P), \" = 0.01\")", parse = TRUE,hjust=0,size=5)

# Evenness and root architecture
P2.even=ggplot()+
  geom_point(data=RootAlphaPurp,aes(PC2,even),alpha=0.5,size=5)+
  geom_smooth(data=RootAlphaPurp,method="lm",aes(PC2,even),fullrange=TRUE)+
  theme_classic()+
  ylab("Evenness")+
  xlab("")+
  Tx2#+ 
  #annotate("text", x = -4.5, y = .0114, label = "paste(italic(R) ^ 2, \" = 0.12\")", parse = TRUE,hjust=0,size=5)+ 
#  annotate("text", x = -4.5, y = .0112, label = "paste(italic(B), \" = -7.29E-5 +/-3.28E-5\")", parse = TRUE,hjust=0,size=5)+
 # annotate("text", x = -4.5, y =.011, label = "paste(italic(P), \" = 0.04\")", parse = TRUE,hjust=0,size=5)


# Root morphology on species diversity Simpson metric

P4.Sim<-ggplot()+
  geom_point(data=RootAlphaPurp,aes(PC4,sim),alpha=0.5,size=5)+
  geom_smooth(data=RootAlphaPurp,method="lm",aes(PC4,sim),fullrange=TRUE)+
  theme_classic()+
  ylab("Simpson")+
  xlab("")+
  Tx2#+
  #annotate("text", x = -5, y = .988, label = "paste(italic(R) ^ 2, \" = 0.18\")", parse = TRUE,hjust=0,size=5)+ 
  #annotate("text", x = -5, y = .985, label = "paste(italic(B), \" = 2.22E-4 +/-6.99E-4\")", parse = TRUE,hjust=0,size=5)+
 # annotate("text", x =-5, y = .982, label = "paste(italic(P), \" < 0.01\")", parse = TRUE,hjust=0,size=5)


P4.simIn=ggplot()+
  geom_point(data=RootAlphaPurp,aes(PC4,InvSimp),alpha=0.5,size=5)+
  geom_smooth(data=RootAlphaPurp,method="lm",aes(PC4,InvSimp),fullrange=TRUE)+
  theme_classic()+
  ylab("Inverse Simpson")+
  xlab("")+
  Tx2#+
 # annotate("text", x = -5, y = 60, label = "paste(italic(R) ^ 2, \" = 0.12\")", parse = TRUE,hjust=0,size=5)+ 
 # annotate("text", x = -5, y = 57, label = "paste(italic(B), \" = 2.08 +/-1.05\")", parse = TRUE,hjust=0,size=5)+
 # annotate("text", x =-5, y = 54, label = "paste(italic(P), \" = 0.02\")", parse = TRUE,hjust=0,size=5)


```


## Linear mixed models

```{r}

### Simpson
SimpLMM=lmer(sim~TRT+Block+(1|ML),alpha%>%filter(Species=="Ip")) 
anova(SimpLMM)
ranova(SimpLMM)

### Inverse Simpson
SimpInvLMM=lmer(InvSimp~TRT+Block+(1|ML),alpha%>%filter(Species=="Ip")) 
anova(SimpInvLMM)
ranova(SimpInvLMM)

### Inverse Simpson
RichLMM=lmer(rich~TRT+Block+(1|ML),alpha%>%filter(Species=="Ip")) 
anova(RichLMM)
ranova(RichLMM)

# Bray curtis metric now


Ax1LMM=lmer(Axis.1~Species+TRT+Block+(1|ML),physeq.pcoa.df)
anova(Ax1LMM)
ranova(Ax1LMM)


Ax2LMM=lmer(Axis.2~Species+TRT+Block+(1|ML),physeq.pcoa.df)
anova(Ax2LMM) # Significant species diffeences in axis 2
ranova(Ax2LMM)


Ax3LMM=lmer(Axis.3~Species+TRT+Block+(1|ML),physeq.pcoa.df)
anova(Ax3LMM) 
ranova(Ax3LMM)

Ax4LMM=lmer(Axis.4~Species+TRT+Block+(1|ML),physeq.pcoa.df)
anova(Ax4LMM) # Marginal species differences
ranova(Ax4LMM)
```


```{r Read in fitness data}
Fitness=read.csv("~/Google Drive File Stream/My Drive/Field_2018/Field_2018_Rcode/CharacterDisplacementRootTraits/CleanData/FitPA4.csv")

library(dplyr)
# Calculate relative fitness
  # First calculate mean seed number by species and treatment---note* we only have seed output of I. purpurea
MeanSeedNumber=aggregate(SeedNumber~Trt+Species,Fitness,mean)

colnames(MeanSeedNumber)=c("Trt","Species","MeanSeedNumber")

Ipurp.Fit=Fitness%>%
  filter(Species=="Ip")

Ipurp.Alpha=alpha%>%
  filter(Species=="Ip")

FitnessPurp=merge(Ipurp.Fit,MeanSeedNumber,by=c("Trt","Species"))
FitnessPurp$RelativeFit=FitnessPurp$SeedNumber/FitnessPurp$MeanSeedNumber
FitnessPurp$Block=as.factor(FitnessPurp$Block)

FitnessPurp2=merge(FitnessPurp,LeafData)
str(FitnessPurp2)
FitnessPurp2$Leaf.Number=as.numeric(as.character(FitnessPurp2$Leaf.Number))

SN1<-lmer(SeedNumber~Trt+Block+Leaf.Number+Block:Trt+(1|ML),FitnessPurp2)
anova(SN1) # Treatment is significant effect on plant seed number; Significant Treatment by Block effect

ggplot(FitnessPurp,aes(Trt,RelativeFit,fill=Block))+
  geom_boxplot()+
  scale_fill_brewer("Paired")+
  theme_classic()+
  ylab("Relative Fitness")+
  ggtitle("Relative Fitness by Treatment and Block")

# Remove size effects from fitness
StdFitness=FitnessPurp2[c("Trt","Species","Block","ML","RelativeFit","Leaf.Number")] # Subset fitness data for variables of interest

# Run one-way ANOVA to remove size effect--i.e., keep residuals
StdFitness$RelativeFitness=residuals(lm(RelativeFit~Leaf.Number,FitnessPurp2)) 

# Compare residuals and non-standard values of fitness
dev.off()
plot(StdFitness$RelativeFit,StdFitness$RelativeFitness)

# Average fitness by block, maternal line and treatment--we use NON standardized fitness (ie size effects not removed)
FitAveraged=aggregate(RelativeFit~Block+Trt+ML,FitnessPurp,mean)
colnames(FitAveraged)<-c("Block","Trt","ML","RelativeFitness")
FitAveraged$TRT=FitAveraged$Trt
dim(FitAveraged)
head(FitAveraged)

# Average size
SizeAveraged=aggregate(Leaf.Number~Block+Trt+ML+Species,LeafData,mean)
colnames(SizeAveraged)<-c("Block","Trt","ML","Species","Size")
SizeAveraged$TRT=SizeAveraged$Trt
dim(SizeAveraged)
head(SizeAveraged)

SizePurp<-SizeAveraged%>%filter(Species=="Ip")
```


```{r phenotypic selection}

####  ####  ####  ####  ####  ####   ####
#  Examine selection on microbiome first
####  ####  ####  ####  ####  ####   ####
FitnessPurp$TRT=FitnessPurp$Trt
FitnessPurp$Combos=as.character(FitnessPurp$Combos)
FitnessPurp[which(FitnessPurp$Trt=="Alone"),]$Combos="none"
FitnessPurp$Combos=as.factor(FitnessPurp$Combos)

BrayFit=merge(physeq.pcoa.df,FitAveraged)

FitAlpha=merge(FitAveraged,alpha)
dim(FitAlpha)

ggplot(FitAlpha,aes(TRT,RelativeFitness))+
  geom_boxplot()+
  scale_fill_brewer("Paired")+
  theme_classic()+
  ylab("Relative Fitness")+
  ggtitle("Relative Fitness by Treatment and Block")+
  facet_grid(~Block)


# Combine with root data
library(dplyr)

RootAveraged=aggregate(list(RootData[c("PC1","PC2","PC3","PC4")]),by=list(RootData$Trt,RootData$ML),FUN=mean) 

colnames(RootAveraged)=c("Trt","ML","PC1","PC2","PC3","PC4")
head(RootAveraged)

RootFitAlpha=merge(FitAlpha,RootAveraged)
head(RootFitAlpha)

#RootFitLeafAlpha=merge(RootFitAlpha,LeafData[c("Sample_ID","Leaf.Number")],by="Sample_ID")

#RootFitLeafAlpha$Leaf.Number=as.numeric(as.character(RootFitLeafAlpha$Leaf.Number))


# CombinE root,fitness/bray estimates
RootFitBray=merge(BrayFit,RootAveraged)


# Plot boxplots of averaged root traits
PC2_Box=ggplot(RootAveraged,aes(x="",y=PC2))+
  geom_boxplot()+
  #geom_jitter()+
  xlab("Root Architecture")+
  theme_classic()+
  Tx+ 
  coord_flip()

# Plot boxplots of averaged root traits
PC1_Box=ggplot(RootAveraged,aes(x="",y=PC1))+
  geom_boxplot()+
  #geom_jitter()+
  xlab("Root Topology")+
  theme_classic()+
  Tx+ 
  coord_flip()

# Plot boxplots of averaged root traits
PC4_Box=ggplot(RootAveraged,aes(x="",y=PC4))+
  geom_boxplot()+
  #geom_jitter()+
  xlab("Root Morphology")+
  theme_classic()+
  Tx+ 
  coord_flip()

#ggarrange(P2.rich,P2.even,P4.Sim,P4.simIn,nrow=2,ncol=2)
AB=cowplot::plot_grid(P2.rich,P2.even,align = "hv", ncol = 2,labels =c("A","B"), label_size =22 ,hjust=-11,vjust=1,label_x = -0.16)

ab=cowplot::plot_grid(P4.Sim,P4.simIn,align = "hv", ncol = 2,labels =c("A","B"), label_size =22 ,hjust=-11,vjust=1,label_x = -0.17)


P4.simIn+
  xlab("Root morphology (PC4)")
# Common x title

x.grob <- textGrob("Root morphology (PC4)", 
                   gp=gpar(col="black", fontsize=25), rot=0)

gridExtra::grid.arrange(gridExtra::arrangeGrob(ab,bottom=x.grob,padding = unit(0.5,units = 'in'),nrow=1))

# Common x title
x.grob1 <- textGrob("Root architecture (PC2)", 
                   gp=gpar(col="black", fontsize=25), rot=0)

gridExtra::grid.arrange(gridExtra::arrangeGrob(AB,bottom=x.grob1,padding = unit(0.5,units = 'in'),nrow=1))

```


## Selection on microbe variables

```{r}
# Quadratic microbe term
FitAlpha$even2=(FitAlpha$even*FitAlpha$even)
FitAlpha$rich2=(FitAlpha$rich*FitAlpha$rich)
FitAlpha$InSim2=(FitAlpha$InvSimp*FitAlpha$InvSimp)
FitAlpha$sim2=(FitAlpha$sim*FitAlpha$sim)

```

### Selection on richness
```{r cor selection on richness}
summary(lm(RelativeFitness~Block+rich+rich2,FitAlpha%>%filter(TRT=="Alone")))
summary(lm(RelativeFitness~Block+rich+rich2,FitAlpha%>%filter(TRT!="Alone")))

richness_sel=lm(RelativeFitness~TRT*Block+rich,FitAlpha)
summary(richness_sel) # No evidence of indirect selection
anova(richness_sel)


ggplot(FitAlpha)+
  geom_point(aes(RelativeFitness,rich),alpha=0.5,size=5)+
  geom_smooth(method="lm",aes(RelativeFitness,rich),fullrange=TRUE)+
  theme_classic()+
  ylab("Relative fitness")+
  xlab("Richness")+
  Tx2

```


### Selection on Inverse Simpson
```{r cor selection on Inverse Simpson}
summary(lm(RelativeFitness~Block+InvSimp+InSim2,FitAlpha%>%filter(TRT=="Alone")))
summary(lm(RelativeFitness~Block+InvSimp+InSim2,FitAlpha%>%filter(TRT!="Alone")))

Invn_sel=lm(RelativeFitness~TRT*Block+InvSimp+Block,FitAlpha)
summary(Invn_sel) # No evidence of indirect selection

ggplot(FitAlpha)+
  geom_point(aes(RelativeFitness,InvSimp),alpha=0.5,size=5)+
  geom_smooth(method="lm",aes(RelativeFitness,InvSimp),fullrange=TRUE)+
  theme_classic()+
  ylab("Relative fitness")+
  xlab("Inverse Simpson")+
  Tx2
```

## Selection on Simpson
```{r cor selection on Simpson }
summary(lm(RelativeFitness~Block+sim+sim2,FitAlpha%>%filter(TRT=="Alone")))
summary(lm(RelativeFitness~Block+sim+sim2,FitAlpha%>%filter(TRT!="Alone")))

sim_sel=lm(RelativeFitness~TRT*Block+sim,FitAlpha)
summary(sim_sel) # NS

ggplot(FitAlpha)+
  geom_point(aes(RelativeFitness,sim),alpha=0.5,size=5)+
  geom_smooth(method="lm",aes(RelativeFitness,sim),fullrange=TRUE)+
  theme_classic()+
  ylab("Relative fitness")+
  xlab("Simpson")+
  Tx2
```

## Selection on Evenness
```{r cor selection on Evenness}

summary(lm(RelativeFitness~Block+even+even2 ,FitAlpha%>%filter(TRT=="Alone")))
summary(lm(RelativeFitness~Block+even+even2,FitAlpha%>%filter(TRT!="Alone"))) # Significant quadratic term for evenness on fitnes (super low slope tho)

even_sel=lm(RelativeFitness~Trt*Block+TRT*even2+even,FitAlpha) # if we include block by treatment interaction there is marginal significance for a treatment by evenness squared effect
even_sel2=lm(RelativeFitness~Block+TRT*even2+even,FitAlpha) # if we include block by treatment interaction there is marginal significance for a treatment by evenness squared effect

anova(even_sel,even_sel2) # Based on RSS--second model/simpler one is a bit better
anova(even_sel) # NS

ggplot(FitAlpha)+
  geom_point(aes(RelativeFitness,even),alpha=0.5,size=5)+
  stat_smooth(method="lm",formula = y ~poly(x,2),aes(RelativeFitness,even))+
  theme_classic()+
  ylab("Relative fitness")+
  xlab("Evenness")+
  Tx2
```

```{r Tests of Phenotypic Selection}

# Remove block effects from fitness
RootFitAlpha$FitResidBlk<-resid(lm(RelativeFitness~Block,RootFitAlpha))

RootFitAlpha$Comp<-sub(".*\\-","",RootFitAlpha$Combos)
# PC1 and richness

richPC1=lm(RelativeFitness~PC1*rich*Trt*Block-PC1:rich:Trt:Block,RootFitAlpha)
#summary(richPC1)

anova(richPC1)


# Within treatment w block removed

summary(lm(FitResidBlk~rich+PC1,RootFitAlpha%>%filter(TRT=="Alone")))
summary(lm(FitResidBlk~rich+PC1,RootFitAlpha%>%filter(TRT!="Alone")))


# PC2 and richness
summary(lm(RelativeFitness~PC2*rich*Block,RootFitAlpha%>%filter(TRT=="Alone")))
summary(lm(RelativeFitness~PC2*rich*Block,RootFitAlpha%>%filter(TRT!="Alone")))
richPC2=lm(RelativeFitness~PC2*rich*Trt*Block-PC2:rich:Trt:Block,RootFitAlpha)

anova(richPC2)
# Phenotypic selection on root architecture according to block and treatment--significant interaction between PC2, richness, treatment and block




# PC3 and richness
summary(lm(RelativeFitness~Block*PC3*rich,RootFitAlpha%>%filter(TRT=="Alone")))
summary(lm(RelativeFitness~Block*PC3*rich,RootFitAlpha%>%filter(TRT!="Alone")))

richPC3=lm(RelativeFitness~PC3*rich*Trt*Block-PC3:rich:Trt:Block,RootFitAlpha)

anova(richPC3) # Significant richness effect
summary(richPC3)

# With block removed

Model1a<-(lm(RelativeFitness~rich+PC3,RootFitAlpha%>%filter(TRT=="Alone")))
Model1c<-(lm(RelativeFitness~rich+PC3,RootFitAlpha%>%filter(TRT!="Alone"))) # Richness is significant when Block is not in the model, and marginal with the interaction

summary(Model1a)
summary(Model1c)


# Significant Block effects
# PC3:rich:Block Significant
# TRT:Block significant
# PC3:rich:TRT significant

# PC4 and richness
richPC4=lm(RelativeFitness~PC4*rich*Trt*Block-PC4:rich:Trt:Block,RootFitAlpha)

anova(richPC4)


# Significant PC4:Block
# PC4:Block
# Trt:Block
# rich:TRT:Block
# PC4:rich:TRT:Block
# Block

# PC3 and simpson
simPC1<-(lm(RelativeFitness~PC1*sim*TRT*Block-PC1:sim:TRT:Block,RootFitAlpha))

anova(simPC1)
# PC1:TRT:Block Significant
# PC1:Block
# Block


# PC2 and simpson
simPC2<-(lm(RelativeFitness~PC2*sim*TRT*Block-PC2:sim:TRT:Block,RootFitAlpha))

anova(simPC2)
summary(simPC2)

Model1a<-(lm(RelativeFitness~sim*PC2*Block,RootFitAlpha%>%filter(TRT=="Alone")))
Model1c<-(lm(RelativeFitness~sim*PC2*Block,RootFitAlpha%>%filter(TRT!="Alone"))) 

summary(Model1a)
summary(Model1c)

# Block sig
# PC2:TRT:Block significant
# PC2:sim:TRT:Block
# Marginal treatment effect 


# PC3 and simpson
simPC3<-(lm(RelativeFitness~PC3*sim*TRT*Block-PC3:sim:TRT:Block,RootFitAlpha))

anova(simPC3)# Marginal simpson
# significant Block
# TRT:Block significant
# PC3:sim:TRT significant
# PC3:TRT:Block 

summary(simPC3)# Marginal simpson


Model1a<-(lm(RelativeFitness~sim+PC3,RootFitAlpha%>%filter(TRT=="Alone")))
Model1c<-(lm(RelativeFitness~sim+PC3,RootFitAlpha%>%filter(TRT!="Alone"))) 

summary(Model1a)
summary(Model1c)



# PC4 and simpson
summary(lm(RelativeFitness~PC4+sim,RootFitAlpha%>%filter(TRT=="Alone")))
summary(lm(RelativeFitness~PC4+sim,RootFitAlpha%>%filter(TRT!="Alone")))


simPC4<-(lm(RelativeFitness~PC4*sim*TRT*Block-PC4:sim:TRT:Block,RootFitAlpha))

anova(simPC4)
# Significant PC4
# Significant Block
# Significant PC4:Block
# Significant sim:TRT:Block



# Inv Simp and PC1
InsimPC1<-(lm(RelativeFitness~PC1*InvSimp*TRT*Block-PC1:InvSimp:TRT:Block,RootFitAlpha))

anova(InsimPC1)# Significant InvSimp
# Significant Block


# Inv Simp and PC2
InsimPC2<-(lm(RelativeFitness~PC2*InvSimp*TRT*Block-PC2:InvSimp:TRT:Block,RootFitAlpha))

anova(InsimPC2)# Significant InvSimp
# Significant Block# Significant Inverse simpson 
# Significant Block
# Significant PC2:TRT:Block 
# Significant PC2:InvSimp:TRT:Block 
# Marginal InvSimp:TRT:Block



# PC3 and Inv Simpson
InsimPC3<-(lm(RelativeFitness~PC3*InvSimp*TRT*Block-PC3:InvSimp:TRT:Block,RootFitAlpha))
anova(lm(RelativeFitness~PC3*InvSimp*TRT+Block,RootFitAlpha))


anova(InsimPC3)# Significant InvSimp

# Plot marginal means

# Within treatment
Model1a<-(lm(RelativeFitness~InvSimp+PC3,RootFitAlpha%>%filter(TRT=="Alone")))
Model1c<-(lm(RelativeFitness~InvSimp+PC3,RootFitAlpha%>%filter(TRT!="Alone"))) 

summary(Model1a)
summary(Model1c)



# Inv simp and PC4
InsimPC4<-(lm(RelativeFitness~PC4*InvSimp*TRT*Block-PC4:InvSimp:TRT:Block,RootFitAlpha))

anova(InsimPC4)# Significant InvSimp
# Significant PC4
# Significant InvSimp
# Significant Block
# Significant PC4:Block
# Significant InvSimp:TRT:Block


# Even and PC1
EvenPC1<-(lm(RelativeFitness~PC1*even*TRT*Block-PC1:even:TRT:Block,RootFitAlpha))

anova(EvenPC1)# Marginal PC1:even:Block
# Significant PC1:TRT:Block 
# Significant PC1:Block 
# Significant even 
# Significant Block




# Even and PC2
EvenPC2<-(lm(RelativeFitness~PC2*even*TRT*Block-PC2:even:TRT:Block,RootFitAlpha))

anova(EvenPC2)# Significant even
# Significant Treatment
# Significant Block
# Significant PC2:TRT:Block
# Significant PC2:even:TRT:Block



# Even and PC3
EvenPC3<-(lm(RelativeFitness~PC3*even*TRT*Block-PC3:even:TRT:Block,RootFitAlpha))

anova(EvenPC3)# Significant even
# Significant Block
# Significant TRT:Block
# Significant PC3:even:Block
# Marginal PC3:TRT:Block  

# Within treatment
Model1a<-(lm(RelativeFitness~even+PC3,RootFitAlpha%>%filter(TRT=="Alone")))
Model1c<-(lm(RelativeFitness~even+PC3,RootFitAlpha%>%filter(TRT!="Alone"))) 

summary(Model1a)
summary(Model1c)

# Even and PC4
EvenPC4<-(lm(RelativeFitness~PC4*even*TRT*Block-PC4:even:TRT:Block,RootFitAlpha))

anova(EvenPC4)# Significant even
# Significant PC4
# Marginal TRT
# Significant Block
# PC4:Block
# Marginal Block:TRT
# Significant PC4:even:TRT:Block

# Within treatment
Model1a<-(lm(RelativeFitness~even*PC4,RootFitAlpha%>%filter(TRT=="Alone")))
Model1c<-(lm(RelativeFitness~even*PC4,RootFitAlpha%>%filter(TRT!="Alone"))) 

summary(Model1a)
summary(Model1c)
```

```{r}


#RootFitAlpha<-merge(SizePurp,RootFitAlpha)

library(interactions)
library(jtools)

# Scale the microbial variables
RootFitAlpha$richScaled<-scale(RootFitAlpha$rich)
RootFitAlpha$SimScaled<-scale(RootFitAlpha$sim)
RootFitAlpha$InvSimScaled<-scale(RootFitAlpha$InvSimp)
RootFitAlpha$EvenScaled<-scale(RootFitAlpha$even)


# Phenotypic selection UNIVARIATE
summary(lm(RelativeFitness~PC1,RootFitAlpha%>%filter(TRT=="Alone"))) 
summary(lm(RelativeFitness~PC1,RootFitAlpha%>%filter(TRT!="Alone"))) 

summary(lm(RelativeFitness~PC1,RootFitAlpha)) 


summary(lm(RelativeFitness~PC2,RootFitAlpha%>%filter(TRT=="Alone"))) 
summary(lm(RelativeFitness~PC2,RootFitAlpha%>%filter(TRT!="Alone"))) 

summary(lm(RelativeFitness~PC2,RootFitAlpha)) 


summary(lm(RelativeFitness~PC4,RootFitAlpha%>%filter(TRT=="Alone"))) 
summary(lm(RelativeFitness~PC4,RootFitAlpha%>%filter(TRT!="Alone"))) 

summary(lm(RelativeFitness~PC4,RootFitAlpha)) 


summary(lm(RelativeFitness~PC3,RootFitAlpha%>%filter(TRT=="Alone"))) 
summary(lm(RelativeFitness~PC3,RootFitAlpha%>%filter(TRT!="Alone"))) 

summary(lm(RelativeFitness~PC3,RootFitAlpha)) 


  # Alpha diversity
summary(lm(RelativeFitness~EvenScaled,RootFitAlpha%>%filter(TRT=="Alone"))) 
summary(lm(RelativeFitness~EvenScaled,RootFitAlpha%>%filter(TRT!="Alone"))) 

anova(lm(RelativeFitness~EvenScaled*TRT,RootFitAlpha))

summary(lm(RelativeFitness~SimScaled,RootFitAlpha%>%filter(TRT=="Alone"))) 
summary(lm(RelativeFitness~SimScaled,RootFitAlpha%>%filter(TRT!="Alone"))) 

anova(lm(RelativeFitness~SimScaled*TRT,RootFitAlpha))


summary(lm(RelativeFitness~InvSimScaled,RootFitAlpha%>%filter(TRT=="Alone"))) 
summary(lm(RelativeFitness~InvSimScaled,RootFitAlpha%>%filter(TRT!="Alone"))) 

anova(lm(RelativeFitness~InvSimScaled*TRT,RootFitAlpha))


summary(lm(RelativeFitness~rich,RootFitAlpha%>%filter(TRT=="Alone"))) 
summary(lm(RelativeFitness~rich,RootFitAlpha%>%filter(TRT!="Alone"))) 

summary(lm(RelativeFitness~rich,RootFitAlpha)) # Significant
anova(lm(RelativeFitness~rich*TRT,RootFitAlpha))


# ANCOVA MUltivariate Selection

# ANCOVA<-(lm(RelativeFitness~TRT+Block+TRT:Block+PC1*Block+PC2*Block+PC3*Block+PC4*Block+richScaled*Block+InvSimScaled*Block+EvenScaled*Block+PC1*TRT*Block+PC2*TRT*Block+PC3*TRT*Block+PC4*TRT*Block+richScaled*TRT*Block+InvSimScaled*TRT*Block+EvenScaled*TRT*Block,RootFitAlpha)) # Full model w Trt by Block interactions per vars



ANCOVA<-(lm(RelativeFitness~TRT+Block+TRT:Block+PC1*TRT+PC2*TRT+PC3*TRT+PC4*TRT+richScaled*TRT+InvSimScaled*TRT+EvenScaled*TRT+PC1*Block+PC2*Block+PC3*Block+PC4*Block+richScaled*Block+InvSimScaled*Block+EvenScaled*Block,RootFitAlpha)) # Full model reported

# Step wise backward regression
library(MASS)

step<-stepAIC(ANCOVA,direction = "backward",trace=FALSE)
step$anova



model<-lm(RelativeFitness ~ TRT + Block + PC1 + PC2 + PC3 + PC4 + richScaled + 
    InvSimScaled + EvenScaled + TRT:Block + TRT:PC1 + TRT:PC3 + 
    TRT:richScaled + TRT:EvenScaled + Block:PC1 + Block:PC2 + 
    Block:PC3 + Block:PC4 + Block:richScaled + Block:InvSimScaled + 
    Block:EvenScaled,RootFitAlpha
)


# anova(model) # Type I sum of squres--sequence order matters, interactions not accounted

car::Anova(model,type="III") # Report the type three sums of squares~
summary(model)
# summary(ANCOVA)

#model2<-lm(RelativeFitness ~ TRT + Block + PC1 + PC2 + PC3 + PC4 + richScaled + InvSimScaled + EvenScaled + TRT:Block + Block:PC1 + Block:PC2 + Block:PC3 + Block:PC4 + Block:richScaled + Block:InvSimScaled + Block:EvenScaled + TRT:PC1 + TRT:PC2 + TRT:PC3 + TRT:PC4 + TRT:Block:PC1 + TRT:Block:PC2 + TRT:Block:PC3 + TRT:Block:PC4,RootFitAlpha)


#interact_plot(ANCOVA,pred=PC1,modx=TRT,partial.residuals=TRUE)

# Multivariate phenotypic selection


# Within treatment
summary(lm(RelativeFitness~PC1+PC2+PC3+PC4+richScaled+InvSimScaled+EvenScaled,RootFitAlpha%>%filter(TRT=="Alone"))) # Alone

summary(lm(RelativeFitness~PC1+PC2+PC3+PC4+richScaled+InvSimScaled+EvenScaled,RootFitAlpha%>%filter(TRT!="Alone"))) # Competition

# report
summary(lm(RelativeFitness~rich,RootFitAlpha%>%filter(TRT=="Alone"))) # Alone
summary(lm(RelativeFitness~rich,RootFitAlpha%>%filter(TRT!="Alone"))) # Competition

# plot
ggplot(data=RootFitAlpha,aes(rich,RelativeFitness,color=TRT))+
geom_point(alpha=0.5,size=3) + 
geom_smooth(method=lm, se=FALSE, fullrange=TRUE,size=2)+
  theme_classic()+
  xlab("Richness")+
  Tx+
  theme(axis.text.x = element_text(angle=0,hjust = 0.5),axis.text=element_text(color="black",size=15))+ 
  scale_color_manual(values = c("#d8b365","#5ab4ac"),"Treatment", labels = c("Alone", "Competition"))+ 
  theme(legend.position = c(0.2, 0.9))





# Plot
EvenPlot1<-ggplot()+
  geom_point(data=RootFitAlpha%>%filter(TRT=="Alone"),aes(EvenScaled,RelativeFitness),size=3,alpha=0.5)+
#    geom_smooth(data=RootFitAlpha%>%filter(TRT=="Alone"),aes(even,RelativeFitness),method="lm",fullrange=TRUE,se=FALSE)+
  geom_abline(slope=-0.47,intercept = 1.18,color="blue",size=2)+
  theme_classic()+
  xlab("Evenness")+
  Tx+
  theme(axis.text.x = element_text(angle=45),axis.text=element_text(color="black",size=15,vjust = 0.5,hjust=1))+
  scale_x_continuous(breaks = scales::pretty_breaks(n = 5))


EvenPlot2<-ggplot()+
  geom_point(data=RootFitAlpha%>%filter(TRT=="Inter"),aes(EvenScaled,RelativeFitness),size=3,alpha=0.5)+
#    geom_smooth(data=RootFitAlpha%>%filter(TRT=="Inter"),aes(EvenScaled,RelativeFitness),method="lm",fullrange=TRUE,se=FALSE)+
    geom_abline(slope=-0.28,intercept = 1.03,color="blue",size=2)+

  theme_classic()+
  xlab("Evenness")+
  Tx+
  theme(axis.text.x = element_text(angle=45),axis.text=element_text(color="black",size=15,vjust = 0.5,hjust=1))+
  scale_x_continuous(breaks = scales::pretty_breaks(n = 5))

ggplot()+
  geom_point(data=RootFitAlpha,aes(EvenScaled,RelativeFitness,color=TRT),size=3,alpha=0.5)+
#    geom_smooth(data=RootFitAlpha%>%filter(TRT=="Inter"),aes(EvenScaled,RelativeFitness),method="lm",fullrange=TRUE,se=FALSE)+
    geom_abline(slope=-0.47,intercept = 1.18,color="red",size=2,linetype="dashed")+

    geom_abline(slope=-0.28,intercept = 1.03,color="black",size=2)+

  theme_classic()+
  xlab("Evenness")+
  Tx2+
  theme(axis.text.x = element_text(angle=45),axis.text=element_text(color="black",size=15,vjust = 0.5,hjust=1))+
  scale_x_continuous(breaks = scales::pretty_breaks(n = 5)) + scale_color_manual(values = c("red","black"),"Treatment", labels = c("Alone", "Competition"))


#ggarrange(P2.rich,P2.even,P4.Sim,P4.simIn,nrow=2,ncol=2)
cowplot::plot_grid(EvenPlot1,EvenPlot2,align = "hv", ncol = 2,labels =c("A","B"), label_size =22 ,hjust=-9,vjust=2,label_x = -0.16)




Block1<-ggplot()+
  geom_point(data=RootFitAlpha%>%filter(Block=="1"),aes(even,RelativeFitness),size=3,alpha=0.5)+
    geom_smooth(data=RootFitAlpha%>%filter(Block=="1"),aes(even,RelativeFitness),se=FALSE,method="lm",fullrange=TRUE)+
    theme_classic()+
  xlab("Eveness")+
  Tx+
  theme(axis.text.x = element_text(angle=45),axis.text=element_text(color="black",size=15,vjust = 0.5,hjust=1))
   
Block2<-ggplot()+
  geom_point(data=RootFitAlpha%>%filter(Block=="2"),aes(even,RelativeFitness),size=3,alpha=0.5)+
    geom_smooth(data=RootFitAlpha%>%filter(Block=="2"),aes(even,RelativeFitness),se=FALSE,method="lm",fullrange=TRUE)+
    theme_classic()+
  xlab("Eveness")+
  Tx+
  theme(axis.text.x = element_text(angle=45),axis.text=element_text(color="black",size=15,vjust = 0.5,hjust=1))


Block3<-ggplot()+
  geom_point(data=RootFitAlpha%>%filter(Block=="3"),aes(even,RelativeFitness),size=3,alpha=0.5)+
    geom_smooth(data=RootFitAlpha%>%filter(Block=="3"),aes(even,RelativeFitness),se=FALSE,method="lm",fullrange=TRUE)+
    theme_classic()+
  xlab("Eveness")+
  Tx+
  theme(axis.text.x = element_text(angle=45),axis.text=element_text(color="black",size=15,vjust = 0.5,hjust=1))


Block4<-ggplot()+
  geom_point(data=RootFitAlpha%>%filter(Block=="4"),aes(even,RelativeFitness),size=3,alpha=0.5)+
    geom_smooth(data=RootFitAlpha%>%filter(Block=="4"),aes(even,RelativeFitness),method="lm",fullrange=TRUE)+
    theme_classic()+
  xlab("Eveness")+
  Tx+
  theme(axis.text.x = element_text(angle=45),axis.text=element_text(color="black",size=15,vjust = 0.5,hjust=1))

# Modeling each diversity metric alone w ea root trait

summary(lm(RelativeFitness~PC1+PC2+PC3+PC4+sim,RootFitAlpha%>%filter(TRT=="Alone")))
summary(lm(RelativeFitness~PC1+PC2+PC3+PC4+sim,RootFitAlpha%>%filter(TRT!="Alone")))

#anova(lm(RelativeFitness~PC1*TRT*sim+PC2*TRT*sim+PC3*TRT*sim+PC4*TRT*sim,RootFitAlpha))


summary(lm(RelativeFitness~PC1+PC2+PC3+PC4+InvSimp,RootFitAlpha%>%filter(TRT=="Alone")))
summary(lm(RelativeFitness~PC1+PC2+PC3+PC4+InvSimp,RootFitAlpha%>%filter(TRT!="Alone")))

#anova(lm(RelativeFitness~PC1*TRT*InvSimp+PC2*TRT*InvSimp+PC3*TRT*InvSimp+PC4*TRT*InvSimp,RootFitAlpha))

summary(lm(RelativeFitness~PC1+PC2+PC3+PC4+even,RootFitAlpha%>%filter(TRT=="Alone")))
summary(lm(RelativeFitness~PC1+PC2+PC3+PC4+even,RootFitAlpha%>%filter(TRT!="Alone")))



summary(lm(RelativeFitness~PC1+PC2+PC3+PC4+rich,RootFitAlpha%>%filter(TRT=="Alone")))
summary(lm(RelativeFitness~PC1+PC2+PC3+PC4+rich,RootFitAlpha%>%filter(TRT!="Alone")))


# Interactions on fitness trait by alpha
EvenPC<-lm(RelativeFitness~TRT+Block+TRT:Block+TRT*PC1*EvenScaled+TRT*PC2*EvenScaled+TRT*PC3*EvenScaled+TRT*PC4*EvenScaled,RootFitAlpha)
anova(EvenPC)

simPC<-lm(RelativeFitness~TRT+Block+TRT:Block+TRT*PC1*SimScaled+TRT*PC2*SimScaled+TRT*PC3*SimScaled+TRT*PC4*SimScaled,RootFitAlpha)
anova(simPC)


richPC<-lm(RelativeFitness~TRT+Block+TRT:Block+TRT*PC1*richScaled+TRT*PC2*richScaled+TRT*PC3*richScaled+TRT*PC4*richScaled,RootFitAlpha)
anova(richPC)

InSimPC<-lm(RelativeFitness~TRT+Block+TRT:Block+TRT*PC1*InvSimScaled+TRT*PC2*InvSimScaled+TRT*PC3*InvSimScaled+TRT*PC4*InvSimScaled,RootFitAlpha)
anova(InSimPC)


summary(lm(RelativeFitness~Block+PC1*InvSimScaled+PC2*InvSimScaled+PC3*InvSimScaled+PC4*InvSimScaled,RootFitAlpha%>%filter(TRT=="Alone")))

summary(lm(RelativeFitness~Block+PC1*InvSimScaled+PC2*InvSimScaled+PC3*InvSimScaled+PC4*InvSimScaled,RootFitAlpha%>%filter(TRT!="Alone")))


summary(lm(RelativeFitness~Block+PC1*richScaled+PC2*richScaled+PC3*richScaled+PC4*richScaled,RootFitAlpha%>%filter(TRT=="Alone")))

summary(lm(RelativeFitness~Block+PC1*richScaled+PC2*richScaled+PC3*richScaled+PC4*richScaled,RootFitAlpha%>%filter(TRT!="Alone")))


summary(lm(RelativeFitness~Block+PC1*richScaled+PC2*richScaled+PC3*richScaled+PC4*richScaled,RootFitAlpha%>%filter(TRT=="Alone")))

summary(lm(RelativeFitness~Block+PC1*richScaled+PC2*richScaled+PC3*richScaled+PC4*richScaled,RootFitAlpha%>%filter(TRT!="Alone")))
```


# Plotting 3D Plane

```{r}
library(scatterplot3d) # This library will allow us to draw 3d plot
library("plot3D")

#Subset by treatment
RootFitAlphaAlone=RootFitAlpha%>%filter(TRT=="Alone")
RootFitAlphaComp=RootFitAlpha%>%filter(TRT!="Alone")

# Input data
x <- RootFitAlphaAlone$PC3
y <- RootFitAlphaAlone$sim
z <- RootFitAlphaAlone$RelativeFitness


# Compute the linear regression (z = ax + by + d)
fit <- lm(z ~ x + y)
# predict values on regular xy grid
grid.lines = 26
x.pred <- seq(min(x), max(x), length.out = grid.lines)
y.pred <- seq(min(y), max(y), length.out = grid.lines)
xy <- expand.grid( x = x.pred, y = y.pred)
z.pred <- matrix(predict(fit, newdata = xy), 
                 nrow = grid.lines, ncol = grid.lines)
# fitted points for droplines to surface
fitpoints <- predict(fit)

# Root trait × Treatment × Simpson diversity

# scatter plot with regression plane
scatter3D(x, y, z, pch = 18, cex = 2, 
    theta =135, phi = 10, colvar = NULL, col = "blue",
    xlab = "Root Size", ylab = "Simpson Diversity", zlab = "Relative Fitness",  
    surf = list(x = x.pred, y = y.pred, z = z.pred,  
    facets = NA, fit = fitpoints), main = "Absence of Competition")



# Repeat for competition treatment
# Input data
x <- RootFitAlphaComp$PC3
y <- RootFitAlphaComp$sim
z <- RootFitAlphaComp$RelativeFitness


# Compute the linear regression (z = ax + by + d)
fit <- lm(z ~ x + y)
# predict values on regular xy grid
grid.lines = 26
x.pred <- seq(min(x), max(x), length.out = grid.lines)
y.pred <- seq(min(y), max(y), length.out = grid.lines)
xy <- expand.grid( x = x.pred, y = y.pred)
z.pred <- matrix(predict(fit, newdata = xy), 
                 nrow = grid.lines, ncol = grid.lines)
# fitted points for droplines to surface
fitpoints <- predict(fit)
# scatter plot with regression plane

s3d <- scatterplot3d(x,y,z,  highlight.3d=FALSE, scale.y=.5, pch=16, main = "Presence of Competition",
    xlab = "Root Size", ylab = "Simpson Diversity", zlab = "Relative Fitness", color="steelblue",angle=30) # Now adding some points to the "scatterplot3d"


s3d$points3d(seq(10,20,2), seq(85,60,-5), seq(60,10,-10),col="steelblue", type="h", pch=16,scale=2)# Now adding a regression plane to the "scatterplot3d"attach(trees)
my.lm <- lm(z ~ x + y)
s3d$plane3d(my.lm, lty.box = "solid")


scatter3D(x, y, z, pch = 18, cex = 2, 
    theta =45, phi = 10, colvar = NULL, col = "blue",
    xlab = "Root Size", ylab = "Simpson Diversity", zlab = "Relative Fitness",  
    surf = list(x = x.pred, y = y.pred, z = z.pred,  
    facets = NA, fit = fitpoints), main = "Presence of Competition")

points3D(x, y, z, pch = 16, col="black", alpha = 0.8, add=TRUE)

# Root trait × Treatment × Inverse Simpson diversity

  # Competition treatment
  y <- RootFitAlphaComp$InvSimp
  
  # Compute the linear regression (z = ax + by + d)
  fit <- lm(z ~ x + y)
  # predict values on regular xy grid
  grid.lines = 26
  x.pred <- seq(min(x), max(x), length.out = grid.lines)
  y.pred <- seq(min(y), max(y), length.out = grid.lines)
  xy <- expand.grid( x = x.pred, y = y.pred)
  z.pred <- matrix(predict(fit, newdata = xy), 
                   nrow = grid.lines, ncol = grid.lines)
  
  scatter3D(x, y, z, pch = 18, cex = 2, 
      theta =45, phi = 10, colvar = NULL, col = "blue",
      xlab = "Root Size", ylab = "Inverse Simpson Diversity", zlab = "Relative Fitness",  
      surf = list(x = x.pred, y = y.pred, z = z.pred,  
      facets = NA, fit = fitpoints), main = "Presence of Competition")
  
  points3D(x, y, z, pch = 16, col="black", alpha = 0.8, add=TRUE)

  # Absence of competition treatment
  y <- RootFitAlphaAlone$InvSimp
  x<-RootFitAlphaAlone$PC3
  z<-RootFitAlphaAlone$RelativeFitness
  # Compute the linear regression (z = ax + by + d)
  fit <- lm(z ~ x + y)
  # fitted points for droplines to surface
  fitpoints <- predict(fit)
  # predict values on regular xy grid
  grid.lines = 26
  x.pred <- seq(min(x), max(x), length.out = grid.lines)
  y.pred <- seq(min(y), max(y), length.out = grid.lines)
  xy <- expand.grid( x = x.pred, y = y.pred)
  z.pred <- matrix(predict(fit, newdata = xy), 
                   nrow = grid.lines, ncol = grid.lines)
  
  scatter3D(x, y, z, pch = 18, cex = 2, 
      theta =45, phi = 10, colvar = NULL, col = "blue",
      xlab = "Root Size", ylab = "Inverse Simpson Diversity", zlab = "Relative Fitness",  
      surf = list(x = x.pred, y = y.pred, z = z.pred,  
      facets = NA, fit = fitpoints), main = "Absence of Competition")
  
# Root trait × Treatment × Richness
  
    # Competition treatment
  y <- RootFitAlphaComp$rich
  x<-RootFitAlphaComp$PC3
  z<-RootFitAlphaComp$RelativeFitness  
  # Compute the linear regression (z = ax + by + d)
  fit <- lm(z ~ x + y)
  fitpoints <- predict(fit)

  # predict values on regular xy grid
  grid.lines = 26
  x.pred <- seq(min(x), max(x), length.out = grid.lines)
  y.pred <- seq(min(y), max(y), length.out = grid.lines)
  xy <- expand.grid( x = x.pred, y = y.pred)
  z.pred <- matrix(predict(fit, newdata = xy), 
                   nrow = grid.lines, ncol = grid.lines)
  
  scatter3D(x, y, z, pch = 18, cex = 2, 
      theta =45, phi = 10, colvar = NULL, col = "blue",
      xlab = "Root Size", ylab = "Richness", zlab = "Relative Fitness",  
      surf = list(x = x.pred, y = y.pred, z = z.pred,  
      facets = NA, fit = fitpoints), main = "Presence of Competition")
  

  # Absence of competition treatment
  y <- RootFitAlphaAlone$rich
  x<-RootFitAlphaAlone$PC3
  z<-RootFitAlphaAlone$RelativeFitness
  # Compute the linear regression (z = ax + by + d)
  fit <- lm(z ~ x + y)
  # fitted points for droplines to surface
  fitpoints <- predict(fit)
  # predict values on regular xy grid
  grid.lines = 26
  x.pred <- seq(min(x), max(x), length.out = grid.lines)
  y.pred <- seq(min(y), max(y), length.out = grid.lines)
  xy <- expand.grid( x = x.pred, y = y.pred)
  z.pred <- matrix(predict(fit, newdata = xy), 
                   nrow = grid.lines, ncol = grid.lines)
  
  scatter3D(x, y, z, pch = 18, cex = 2, 
      theta =45, phi = 10, colvar = NULL, col = "blue",
      xlab = "Root Size", ylab = "Richness", zlab = "Relative Fitness",  
      surf = list(x = x.pred, y = y.pred, z = z.pred,  
      facets = NA, fit = fitpoints), main = "Absence of Competition")
  
```

# Quadratic relationships w fitness

```{r}
RootFitAlpha$rich2<-RootFitAlpha$rich*RootFitAlpha$rich
RootFitAlpha$sim2<-RootFitAlpha$sim*RootFitAlpha$sim
RootFitAlpha$InvSimp2<-RootFitAlpha$InvSimp*RootFitAlpha$InvSimp
RootFitAlpha$even2<-RootFitAlpha$even*RootFitAlpha$even

AncovRich<-lm(RelativeFitness~rich2+rich+rich2*Block*Trt,RootFitAlpha)
AncovSim<-lm(RelativeFitness~sim2+sim+sim2*Block*Trt,RootFitAlpha)
AncovInSim<-lm(RelativeFitness~InvSimp2+InvSimp+InvSimp2*Block*Trt,RootFitAlpha)
AncovEven<-lm(RelativeFitness~even2+even+even2*Block*Trt,RootFitAlpha)

anova(AncovRich) # Significant quadratic richness term
anova(AncovSim) #  NS
anova(AncovInSim) # Significant quadratic Inverse Simpson term
anova(AncovEven) # Significant quadratic Even term
```

# Quadratic w Root Size

```{r}

# Include root size and interactions as covariates 
AncovRich<-lm(RelativeFitness~rich2+rich+rich2*Block*Trt*PC3-rich2:Block:TRT:PC3,RootFitAlpha)

AncovSim<-lm(RelativeFitness~sim2+sim+sim2*Block*Trt*PC3-sim2:Block:TRT:PC3,RootFitAlpha)

AncovInSim<-lm(RelativeFitness~InvSimp2+InvSimp+InvSimp2*Block*Trt*PC3-InvSimp2:Block:TRT:PC3,RootFitAlpha)
AncovEven<-lm(RelativeFitness~even2+even+even2*Block*Trt*PC3-even2:Block:TRT:PC3,RootFitAlpha)

anova(AncovRich) # Significant quadratic richness term, NS treatment interaction
anova(AncovSim) #  Significant quadratic Inverse Simpson term, significant trt by root by microbe **
anova(AncovInSim) # Significant quadratic Inverse Simpson term, significant trt by root by microbe **
anova(AncovEven) # Significant quadratic Even term, NS treatment


# Within treatment for inverse simpson and simpson diversity
Sim_Size_Alone<-lm(RelativeFitness~InvSimp2+PC3,RootFitAlpha %>% filter(TRT=="Alone"))
summary(Sim_Size_Alone)

Sim_Size_Comp<-lm(RelativeFitness~InvSimp2+PC3,RootFitAlpha %>% filter(TRT!="Alone"))
summary(Sim_Size_Comp)

```






# MANTEL test to examine how microbiome disimilarity is correlated root phenotype distance
```{r,include=F,render=F}
# Here I use observed values of root traits 

# Load matrix Bray distances of OTU abundance
OTU_table=t(otu_table(physeq1)) # Write out OTU table


# Pull out Root traits of interest and save these to the Sampled data frame
SampledRoots=merge(RootAlphaObs,sampledf)


OTU_table=OTU_table[row.names(OTU_table)%in%SampledRoots$Sample_ID,]


    OTU=OTU_table
    Roots=SampledRoots

  # Calculate root architecture distances with euclidean distance 

    PC2=Roots$PC2 # isolate PC2, i.e. root architecture
    PC2.dist=dist(PC2)

  # Calculate Bray distance matrix for OTU table

    Bray=vegdist(OTU,method="bray")


    
# OTU Bray vs Root architecture

    OTU_pc2 = mantel(Bray, PC2.dist, method = "spearman", permutations = 9999, na.rm = TRUE)

    # Marginally significant--very low r value
    # Mantel statistic r: 0.03795 
    # Significance: 0.1166 
    
# Reapat for root topology, size and morphology

  PC1=Roots$PC1 # isolate 
  PC1.dist=dist(PC1)
  PC3=Roots$PC3 # isolate 
  PC3.dist=dist(PC3)
  PC4=Roots$PC1 # isolate 
  PC4.dist=dist(PC4)

# Examine overall distances in root system; i.e. use all PCs in distance calculation

    PCall=Roots[grep("PC",names(Roots))]
    PC.dist=dist(PCall)

    OTU_pc = mantel(Bray, PC.dist, method = "spearman", permutations = 9999, na.rm = TRUE)

###             examine mantel test using observed values of roots ###

OTU_pc1 = mantel(Bray,PC1.dist, method = "spearman", permutations = 9999, na.rm = TRUE)
OTU_pc2 = mantel(Bray,PC2.dist, method = "spearman", permutations = 9999, na.rm = TRUE)
OTU_pc3 = mantel(Bray,PC3.dist, method = "spearman", permutations = 9999, na.rm = TRUE)
OTU_pc4 = mantel(Bray,PC4.dist, method = "spearman", permutations = 9999, na.rm = TRUE)

  # Repeat but standardize for Block
  
  Standardize=function(x,data){
  StandData=residuals(lm(x~Block,data))
  return(StandData)
  }
  
  PC1_resid=Standardize(x=PC1,data=Roots)
  PC2_resid=Standardize(x=PC2,data=Roots)
  PC3_resid=Standardize(x=PC1,data=Roots)
  PC4_resid=Standardize(x=PC1,data=Roots)
  
  
    PC1.distR=dist(PC1_resid)
    PC2.distR=dist(PC2_resid)
    PC3.distR=dist(PC3_resid)
    PC4.distR=dist(PC4_resid)
  
  
  
  OTU_pc1_st = mantel(Bray,PC1.distR, method = "spearman", permutations = 9999, na.rm = TRUE)
  OTU_pc2_st = mantel(Bray,PC2.distR, method = "spearman", permutations = 9999, na.rm = TRUE)
  OTU_pc3_st = mantel(Bray,PC3.distR, method = "spearman", permutations = 9999, na.rm = TRUE)
  OTU_pc4_st = mantel(Bray,PC4.distR, method = "spearman", permutations = 9999, na.rm = TRUE)
  
  # RE RUN WITHIN I. PURP ONLY
  
# Pull out Root traits of interest and save these to the Sampled data frame
SampledRoots=merge(RootAlphaObs,sampledf)
SampledRootsIp=subset(SampledRoots,Species=="Ip")

OTU_table=OTU_table[row.names(OTU_table)%in%SampledRootsIp$Sample_ID,]


    OTU=OTU_table
    Roots=SampledRootsIp

  # Calculate root architecture distances with euclidean distance 

    PC2=Roots$PC2 # isolate PC2, i.e. root architecture
    PC2.dist=dist(PC2)

  # Calculate Bray distance matrix for OTU table

    Bray=vegdist(OTU,method="bray")


    
# OTU Bray vs Root architecture

    OTU_pc2 = mantel(Bray, PC2.dist, method = "spearman", permutations = 9999, na.rm = TRUE)

    # Marginally significant--very low r value
    # Mantel statistic r: 0.06836  
    # Significance: 0.07
    
# Reapat for root topology, size and morphology

  PC1=Roots$PC1 # isolate 
  PC1.dist=dist(PC1)
  PC3=Roots$PC3 # isolate 
  PC3.dist=dist(PC3)
  PC4=Roots$PC1 # isolate 
  PC4.dist=dist(PC4)

# Examine overall distances in root system; i.e. use all PCs in distance calculation

    PCall=Roots[grep("PC",names(Roots))]
    PC.dist=dist(PCall)

    OTU_pc = mantel(Bray, PC.dist, method = "spearman", permutations = 9999, na.rm = TRUE)

###             examine mantel test using observed values of roots ###

OTU_pc1 = mantel(Bray,PC1.dist, method = "spearman", permutations = 9999, na.rm = TRUE)
# OTU_pc2 = mantel(Bray,PC2.dist, method = "spearman", permutations = 9999, na.rm = TRUE)
OTU_pc3 = mantel(Bray,PC3.dist, method = "spearman", permutations = 9999, na.rm = TRUE)
OTU_pc4 = mantel(Bray,PC4.dist, method = "spearman", permutations = 9999, na.rm = TRUE)

# Repeat but standardize for Block
  
  Standardize=function(x,data){
  StandData=residuals(lm(x~Block,data))
  return(StandData)
  }
  
  PC1_resid=Standardize(x=PC1,data=Roots)
  PC2_resid=Standardize(x=PC2,data=Roots)
  PC3_resid=Standardize(x=PC1,data=Roots)
  PC4_resid=Standardize(x=PC1,data=Roots)
  
  
    PC1.distR=dist(PC1_resid)
    PC2.distR=dist(PC2_resid)
    PC3.distR=dist(PC3_resid)
    PC4.distR=dist(PC4_resid)
  
  
  
  OTU_pc1_st = mantel(Bray,PC1.distR, method = "spearman", permutations = 9999, na.rm = TRUE)
  OTU_pc2_st = mantel(Bray,PC2.distR, method = "spearman", permutations = 9999, na.rm = TRUE)
  OTU_pc3_st = mantel(Bray,PC3.distR, method = "spearman", permutations = 9999, na.rm = TRUE)
  OTU_pc4_st = mantel(Bray,PC4.distR, method = "spearman", permutations = 9999, na.rm = TRUE)
  
```




### MANTEL between Bray Curtis and Relative Fitnesses
```{r}
#  Here we use the Family mean values of root traits---this would indicate evidence for 'phenotypic selection' 

  # Load matrix Bray distances of OTU abundance
  OTU_table=t(otu_table(physeq1)) # Write out OTU table
  

  # Pull out Root traits of interest and save these to the Sampled data frame
  SampledFit=merge(FitAveraged,sampledf,by=c("TRT","ML","Block"))

  # Subset per treatment
  
SampledFitComp=SampledFit%>%filter(TRT=="Inter")
OTU_table_Comp=OTU_table[row.names(OTU_table)%in%SampledFitComp$Sample_ID,]

SampledFitAlone=SampledFit%>%filter(TRT!="Inter")
OTU_table_Alone=OTU_table[row.names(OTU_table)%in%SampledFitAlone$Sample_ID,]

    OTU_Comp=OTU_table_Comp
    Fit_Comp=SampledFitComp
  
    OTU_Alone=OTU_table_Alone
    Fit_Alone=SampledFitAlone
    # Calculate fitness distances w euclidean distance 

    Fit.distComp=dist(Fit_Comp$RelativeFitness)
    Fit.distAlone=dist(Fit_Alone$RelativeFitness)

    # Calculate Bray distance matrix for OTU table
    BrayComp=vegdist(OTU_Comp,method="bray")
    BrayAlone=vegdist(OTU_Alone,method="bray")


    # OTU Bray vs Fitness per treatment

    OTU_Fit_Comp = mantel(BrayComp, Fit.distComp, method = "spearman", permutations = 9999, na.rm = TRUE)
    OTU_Fit_Alone = mantel(BrayAlone, Fit.distAlone, method = "spearman", permutations = 9999, na.rm = TRUE)
    
    
# Run partial mantel test and control for plant size--i.e., plant size distance matrix
    
    # First  average combined fitness and leaf data 
    Fit2Average=FitnessPurp2%>%
      filter(Species=="Ip")%>%
      group_by(ML,Block,Trt)%>%
      summarise("RelativeFitAv"=mean(RelativeFit,rm.na=T),"LeafAv"=mean(Leaf.Number,rm.na=T))
    Fit2Average$TRT=Fit2Average$Trt
  
    # Pull out Root traits of interest and save these to the Sampled data frame
  SampledFit=merge(Fit2Average,sampledf,by=c("TRT","ML","Block"))

# Subset per treatment
  
  SampledFitComp=SampledFit%>%filter(TRT=="Inter")
  OTU_table_Comp=OTU_table[row.names(OTU_table)%in%SampledFitComp$Sample_ID,]
  
  SampledFitAlone=SampledFit%>%filter(TRT!="Inter")
  OTU_table_Alone=OTU_table[row.names(OTU_table)%in%SampledFitAlone$Sample_ID,]

    OTU_Comp=OTU_table_Comp
    Fit_Comp=SampledFitComp
  
    Fit_Alone=SampledFitAlone
    
    OTU_Alone=OTU_table_Alone

     # Remove NAS
    # Remove=which(Fit_Alone$LeafAv%in%NA)
    
    # Calculate fitness distances w euclidean distance 

    Fit.distComp=dist(Fit_Comp$RelativeFitAv)
    Fit.distAlone=dist(Fit_Alone[,"RelativeFitAv"])
    
    # Calculate size distances w euclidean distance 

    Leaf.distComp=dist(Fit_Comp$LeafAv)
    Leaf.distAlone=dist(Fit_Alone[,"LeafAv"])


    # Calculate Bray distance matrix for OTU table
    BrayComp=vegdist(OTU_Comp,method="bray")
    BrayAlone=vegdist(OTU_Alone,method="bray")


    # OTU Bray vs Fitness per treatment

    OTU_Fit_Comp_Par = mantel.partial(BrayComp, Fit.distComp, Leaf.distComp, method = "spearman", permutations = 9999, na.rm = TRUE)
    
    OTU_Fit_Alone_Par = mantel.partial(BrayAlone, Fit.distAlone,Leaf.distAlone, method = "spearman", permutations = 9999, na.rm = TRUE)
```



### MANTEL PARTIAL REGRESSION: between Bray Curtis and ROOTS onto Relative Fitnesses
```{r}
#  Here we use the Family mean values of root traits---this would indicate evidence for 'phenotypic selection' 


RootFitAlphaMean<-RootFitAlpha%>%
                    group_by(TRT,ML,Block)%>% #Grouping factor
                    summarise("PC1_Avg"=mean(PC1,na.rm=T),"PC2_Avg"=mean(PC2,na.rm=T),"PC4_Avg"=mean(PC4,na.rm=T),"PC3_Avg"=mean(PC3,na.rm=T),"RelFit"=mean(RelativeFitness,na.rm=T))

  # Load matrix Bray distances of OTU abundance
  OTU_table=t(otu_table(physeq1)) # Write out OTU table
  

  # Pull out Root traits of interest and save these to the Sampled data frame
  SampledFit=merge(RootFitAlphaMean,sampledf,by=c("TRT","ML","Block"))

  # Subset per treatment
  
SampledFitComp=SampledFit%>%filter(TRT=="Inter")
OTU_table_Comp=OTU_table[row.names(OTU_table)%in%SampledFitComp$Sample_ID,]

SampledFitAlone=SampledFit%>%filter(TRT!="Inter")
OTU_table_Alone=OTU_table[row.names(OTU_table)%in%SampledFitAlone$Sample_ID,]

    OTU_Comp=OTU_table_Comp
    Fit_Comp=SampledFitComp
  
    OTU_Alone=OTU_table_Alone
    Fit_Alone=SampledFitAlone
    
    
    # Calculate fitness distances w euclidean distance 

    Fit.distComp=dist(Fit_Comp$RelFit)
    Fit.distAlone=dist(Fit_Alone$RelFit)
    
    # Calculate root distances w euclidean distance 

    PC1.distComp=dist(Fit_Comp$PC1_Avg)
    PC1.distAlone=dist(Fit_Alone$PC1_Avg)
    PC2.distComp=dist(Fit_Comp$PC2_Avg)
    PC2.distAlone=dist(Fit_Alone$PC2_Avg)
    PC3.distComp=dist(Fit_Comp$PC3_Avg)
    PC3.distAlone=dist(Fit_Alone$PC3_Avg)
    PC4.distComp=dist(Fit_Comp$PC4_Avg)
    PC4.distAlone=dist(Fit_Alone$PC4_Avg)
    
    
    # Calculate Bray distance matrix for OTU table
    BrayComp=vegdist(OTU_Comp,method="bray")
    BrayAlone=vegdist(OTU_Alone,method="bray")



# Run partial mantel test and control for ROOT traits
    

    # OTU Bray vs Fitness per treatment

    # Partial regression with root architecture
    OTU_FitPC2_Comp_Par = mantel.partial(BrayComp, Fit.distComp, PC2.distComp, method = "spearman", permutations = 9999, na.rm = TRUE)
    
    OTU_FitPC2_Alone_Par = mantel.partial(BrayAlone, Fit.distAlone,PC2.distAlone, method = "spearman", permutations = 9999, na.rm = TRUE)
    
        # Partial regression with root SIZE

    OTU_FitPC3_Comp_Par = mantel.partial(BrayComp, Fit.distComp, PC3.distComp, method = "spearman", permutations = 9999, na.rm = TRUE)
    
    OTU_FitPC3_Alone_Par = mantel.partial(BrayAlone, Fit.distAlone,PC3.distAlone, method = "spearman", permutations = 9999, na.rm = TRUE)
    
    
            # Partial regression with root morphology
    OTU_FitPC4_Comp_Par = mantel.partial(BrayComp, Fit.distComp, PC4.distComp, method = "spearman", permutations = 9999, na.rm = TRUE)
    
    OTU_FitPC4_Alone_Par = mantel.partial(BrayAlone, Fit.distAlone,PC4.distAlone, method = "spearman", permutations = 9999, na.rm = TRUE)
    
    
          # Partial regression with root topology
    OTU_FitPC1_Comp_Par = mantel.partial(BrayComp, Fit.distComp, PC1.distComp, method = "spearman", permutations = 9999, na.rm = TRUE)
    
    OTU_FitPC1_Alone_Par = mantel.partial(BrayAlone, Fit.distAlone,PC1.distAlone, method = "spearman", permutations = 9999, na.rm = TRUE)
```

