---
title: "Preliminary_Microbiome_analysis"
author: "Sara Colom"
date: "11/13/2019"
output: 
  html_document:
    toc: true
    toc_float: true
    highlight: tango
    code_folding: hide
    self_contained: yes  
---

## Sample sizes

### Table sample number by species and treatment


| Species          | Treatment       | N      |
|--------------    |-------------    |----    |
| I. purpurea      | Alone           | 27     |
| I. purpurea      | Competition     | 78     |
| I. hederacea     | Competition     | 78     |


### Table number of maternal line per species

| Species          | Number of ML     |
|--------------    |--------------    |
| I. purpurea      |      10          |
| I. hederacea     |       5          |



```{r setup,warning=F,comment=F,message=F}
knitr::opts_chunk$set(root.dir = ("/Volumes/GoogleDrive/My Drive/Chapter3MicrobiomeMothur/DataSets/MothurOutput_Mock_Microbiome/Microbiome_Output"))
               
knitr::opts_knit$set(root.dir = ("/Volumes/GoogleDrive/My Drive/Chapter3MicrobiomeMothur/DataSets/MothurOutput_Mock_Microbiome/Microbiome_Output"))
```

### Load Libraries
```{r load_libs, include=T,warning=F,comment=F,message=F}
library(phyloseq)
library(ggplot2)
library(ape)
library(vegan)
library(plyr)
library(dplyr)
library(scales)
library(grid)
library(reshape2)
library(DESeq2)
library(pegas)
library(pgirmess)
library(multcomp)
library(multcompView)
library(ggpubr)
library(RColorBrewer)
library(plotly)
library(ggthemes)
library(corrplot)
library(Hmisc)

source("~/Google Drive File Stream/My Drive/IDM_Experiments-master/miSeq.R")

# Aesthetics
Tx<-theme(axis.text.y = element_text(size=20),
          axis.title.y = element_text(size=20))+
          theme(axis.text.x = element_text(vjust = 1, hjust=1,angle=0,size=20),
          axis.title.x = element_text(angle=0,size=20),
          plot.title=element_text(size=25,hjust=0))


GoldGrey=c("#F1CE63","#79706E")
GreenBlue=c("#59A14F","#4E79A7")

```



## Sequence data analysis
```{r Import Data,warning=F,comment=F,message=F}
### loading mothur output with FWDB+silva taxonomy and sample metadata. 
### Experiments run in 
setwd("/Volumes/GoogleDrive/My Drive/Chapter3MicrobiomeMothur/DataSets/MothurOutput_Mock_Microbiome/Microbiome_Output")
sharedfile <- "stability.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.opti_mcc.shared"
taxfile <- "stability.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.opti_mcc.0.03.cons.taxonomy"

mothurdata <- import_mothur(mothur_shared_file = sharedfile,mothur_constaxonomy_file = taxfile)

sampledata= read.csv('~/Google Drive File Stream/My Drive/Chapter3MicrobiomeMothur/DataSets/MothurOutput_Mock_Microbiome/Microbiome_Output/MetaDataTest.csv')

SAMPLE=sampledata
row.names(SAMPLE)=SAMPLE$Sample_ID

SAMPLE=subset(SAMPLE,SAMPLE$TRT=="Alone"|SAMPLE$TRT=="Inter")
SAMPLE=sample_data(SAMPLE)

### create phyloseq object
physeq.all = merge_phyloseq(mothurdata, SAMPLE) # Modified version worked


### We need to change the taxonomy names: when using the fwdb taxonomy we need to add different headers after removing the last column, which contains no information except for 1 Verrucomicrobia taxon

#   tax_table(physeq.all) <- tax_table(physeq.all)[,-7] # this removes the final column
colnames(tax_table(physeq.all))<-c("Kingdom","Phylum","Class","Order","Family","Genus")

#   tax_table(physeq.all) <-cbind(tax_table(physeq.all),row.names(tax_table(physeq.all)))

### removing non-bacterial reads (was already done in mothur, but just to be safe after merging taxonomies)
#   physeq.all <- subset_taxa(physeq.all, Kingdom == "Bacteria")

```

```{r Proteobacteria phylum change to class,warning=F,comment=F,message=F}

setwd("/Volumes/GoogleDrive/My Drive/Chapter3MicrobiomeMothur/DataSets/MothurOutput_Mock_Microbiome/Microbiome_Output")

### ADD THE PROTEOBACTERIA CLASSES TO THE PHYLA NAME FIELD IN PHYLOSEQ OBJECT TAXONOMY 

#phy <- data.frame(tax_table(physeq.all))
#Phylum <- as.character(phy$Phylum)
#Class <- as.character(phy$Class)
#for  (i in 1:length(Phylum)){ 
#  if (Phylum[i] == "Proteobacteria"){
#    if (Class[i] == "unclassified"){
#      Phylum[i] <- Phylum[i]       
#    } else {
#      Phylum[i] <- Class[i]
#    }
#  } 
#}

phy=read.csv("phy.csv")

Phylum<-as.character(phy$Phylum)
Class=as.character(phy$Class)
phy$Phylum=Phylum
t <- tax_table(as.matrix(phy))

#write.csv(phy,"phy.csv",row.names=F)
```


```{r read in phylum data, include=FALSE,warning=F,comment=F,message=F}
# phy=read.csv("phy.csv")

# tax_table(physeq.all) <- t

SAMPLE$Species=ifelse(grepl("Ip",SAMPLE$ML),"Ip","Ihed")
physeq.all2 = merge_phyloseq(physeq.all, SAMPLE) 
```

## Sequence depth and pruning

```{r data scaling}
physeq=(physeq.all2)
physeq <- prune_taxa(taxa_sums(physeq) > 0, physeq) # Remove taxa with no counts

#check number of reads in each sample, differences in count are in part due differet numbers of chlorophyl reads depending on time of experiment

# Make a data frame with a column for the read counts of each sample
sample_sum_df <- data.frame(sum = sample_sums(physeq))

# Histogram of sample read counts
ggplot(sample_sum_df, aes(x = sum)) + 
  geom_histogram(color = "black", fill = "#59A14F", binwidth = 2500) +
  ggtitle("Distribution of sample sequencing depth") + 
  xlab("Read counts") +
  theme(axis.title.y = element_blank())+
  theme_classic()


# Scales reads to smallest library size 
source("https://raw.githubusercontent.com/michberr/MicrobeMiseq/master/R/miseqR.R")
#physeq.scale <- scale_reads(physeq, min(sample_sums(physeq)))

##### Normalization #######

# Scales reads by 
# 1) taking proportions,
# 2) multiplying by a given library size of n
# 3) rounding down
physeq1=prune_samples(sample_sums(physeq) >20000, physeq)
sample_sum_df1 <- data.frame(sum = sample_sums(physeq1))

# Histogram of sample read counts
ggplot(sample_sum_df1, aes(x = sum)) + 
  geom_histogram(color = "black", fill = "#59A14F", binwidth = 2500) +
  ggtitle("Distribution of sample sequencing depth after pruning") + 
  xlab("Read counts") +
  theme(axis.title.y = element_blank())+
  theme_classic()


n=min(sample_sums(physeq1))
  physeq.scale <-
    transform_sample_counts(physeq1, function(x) {
      (n * x/sum(x))
    })
physeq.scale <- prune_taxa(taxa_sums(physeq.scale) > 0, physeq.scale)


physeq1

```

```{r PCoA Treatment and Species comparisoin Bray Curtis Estimate,warning=F,comment=F,message=F}
# Betadiv pcoa Bray-Curtis DNA only 
physeq.pcoa <-
  ordinate(
    physeq = physeq.scale,
    method = "PCoA",
    distance = "bray"
  )

physeq.pcoa.vectors <- data.frame(physeq.pcoa$vectors[, 1:4])
physeq.pcoa.vectors$Duplicates <- row.names(physeq.pcoa.vectors)
SampData=data.frame(sample_data(physeq))
colnames(SampData)[1]="Duplicates"

SampData=subset(SampData,SampData$TRT=="Inter"|SampData$TRT=="Alone")

physeq.pcoa.df <- droplevels(merge(physeq.pcoa.vectors,SampData,by="Duplicates"))
bray_values <- physeq.pcoa$values
bray_rel_eigens <- bray_values$Relative_eig
bray_rel_eigen1 <- bray_rel_eigens[1]
bray_rel_eigen1_percent <- round(bray_rel_eigen1 * 100, digits = 1)
bray_rel_eigen2 <- bray_rel_eigens[2]
bray_rel_eigen2_percent <- round(bray_rel_eigen2 * 100, digits = 1)
bray_rel_eigen3 <- bray_rel_eigens[3]
bray_rel_eigen3_percent <- round(bray_rel_eigen3 * 100, digits = 1)
bray_rel_eigen4 <- bray_rel_eigens[4]
bray_rel_eigen4_percent <- round(bray_rel_eigen4 * 100, digits = 1)
bray_rel_eigen5 <- bray_rel_eigens[5]
bray_rel_eigen5_percent <- round(bray_rel_eigen5 * 100, digits = 1)
bray_axis1 <- paste("PCoA 1:",bray_rel_eigen1_percent,"%")
bray_axis2 <- paste("PCoA 2:",bray_rel_eigen2_percent,"%")
bray_axis3 <- paste("PCoA 3:",bray_rel_eigen3_percent,"%")
bray_axis4 <- paste("PCoA 4:",bray_rel_eigen4_percent,"%")
PCoA_title <- paste("Bray-Curtis,",ntaxa(physeq.scale),"OTUs")


pcoa_exp_trt <- ggplot(physeq.pcoa.df, aes(Axis.1, Axis.2, color = TRT,fill = TRT)) +
  xlab("")+
  ylab(bray_axis2) +
  geom_point(alpha=0.9) + 
  theme_classic() +
  scale_fill_manual(values = GoldGrey)+
  scale_color_manual(values = GoldGrey)+
  stat_ellipse(geom = "polygon", alpha = 1/6, aes(fill =TRT))+
  Tx


pcoa_exp_trtA <- ggplot(physeq.pcoa.df, aes(Axis.3, Axis.4, color = TRT,fill = TRT)) +
  xlab("")+
  ylab(bray_axis4) + 
  geom_point(alpha=0.9) + 
  theme_classic() +
  scale_fill_manual(values = GoldGrey)+
  scale_color_manual(values = GoldGrey)+
  stat_ellipse(geom = "polygon", alpha = 1/6, aes(fill =TRT))+
  Tx


pcoa_exp_sp <- ggplot(physeq.pcoa.df, aes(Axis.1, Axis.2, color = Species,fill = Species)) +
  xlab(bray_axis1) + 
  ylab(bray_axis2) +
  geom_point(alpha=0.9) + 
  theme_classic() +
  scale_fill_manual(values = GreenBlue)+
  scale_color_manual(values = GreenBlue)+
  stat_ellipse(geom = "polygon", alpha = 1/6, aes(fill =Species))+
  Tx


pcoa_exp_spA <- ggplot(physeq.pcoa.df, aes(Axis.3, Axis.4, color = Species,fill = Species)) +
  xlab(bray_axis3) + 
  ylab(bray_axis4) +
  geom_point(alpha=0.9) + 
  theme_classic() +
  scale_fill_manual(values = GreenBlue)+
  scale_color_manual(values = GreenBlue)+
  stat_ellipse(geom = "polygon", alpha = 1/6, aes(fill =Species))+
  Tx

dev.off()
A=ggarrange(pcoa_exp_trt,pcoa_exp_trtA,common.legend = T)
B=ggarrange(pcoa_exp_sp,pcoa_exp_spA,common.legend = T)

MainFig=ggarrange(A,B,nrow=2)

annotate_figure(MainFig,
                top = text_grob(PCoA_title, face = "bold", size = 25)
)

```

```{r 3D graphic,warning=F,comment=F,message=F}

physeq.pcoa.df$TrtSp=paste(physeq.pcoa.df$TRT,physeq.pcoa.df$Species,sep="")

p <- plot_ly(physeq.pcoa.df, x = ~Axis.1, y = ~Axis.2, z = ~Axis.3, color = ~TrtSp) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = bray_axis1),
                     yaxis = list(title = bray_axis2),
                     zaxis = list(title = bray_axis3)))


p1 <- plot_ly(physeq.pcoa.df, x = ~Axis.1, y = ~Axis.2, z = ~Axis.4, color = ~Species) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = bray_axis1),
                     yaxis = list(title = bray_axis2),
                     zaxis = list(title = bray_axis4)))

p3 <- plot_ly(physeq.pcoa.df, x = ~Axis.1, y = ~Axis.2, z = ~Axis.4, color = ~Species) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = bray_axis1),
                     yaxis = list(title = bray_axis3),
                     zaxis = list(title = bray_axis4)))

```

```{r adonis experimental data when all data combined,warning=F,comment=F,message=F}
## All experiment, add variable treatment, then species
sampledf <- data.frame(sample_data(physeq.scale))

sampledf=subset(sampledf,sampledf$TRT=="Alone"|sampledf$TRT=="Inter")

## Subsample by species 
physeq.purp=subset_samples(physeq.scale, Species == "Ip")

## Subsample within competition
physeq.comp=subset_samples(physeq.scale, TRT=="Inter")



# Calculate bray curtis for experimental samples only
physeq.bray <- phyloseq::distance(physeq = physeq.scale, method = "bray") #acrosss species and treatment
physeq.bray2 <- phyloseq::distance(physeq = physeq.purp, method = "bray") # within Ipurp
physeq.bray3 <- phyloseq::distance(physeq = physeq.comp, method = "bray") # within competition


# Adonis test for treatment, across species
adonis(physeq.bray ~ TRT, data = sampledf)
b = betadisper(physeq.bray,sampledf$TRT)

p <- permutest(b)
p$tab

# Adonis test for treatment, WITHIN species
adonis(physeq.bray2 ~ TRT, data = sampledf%>%filter(Species=="Ip")) # No treatment effect on bray distances

b = betadisper(physeq.bray,sampledf$TRT)
p <- permutest(b)
p$tab

# Adonis test for species 
adonis(physeq.bray3 ~ Species, data = sampledf%>%filter(TRT=="Inter"))
b = betadisper(physeq.bray3,( sampledf%>%filter(TRT=="Inter"))$Species)
p <- permutest(b)
p$tab


sampledf$Block=as.factor(sampledf$Block)

# Nested adonis
adonis(physeq.bray ~ TRT + Species + Block, data = sampledf) # Species effect taking into account block as a fixed effect
```


```{r AMOVA}

# # # # # # # # # # # # # # # # # # # # # 
#             ACROSS SAMPLES
amova(physeq.bray ~ TRT, data = sampledf) # Across all samples
amova(physeq.bray ~ Species, data = sampledf) # Across all samples

# # # # # # # # # # # # # # # # # # # # # 
# Subsample for within I. purpurea only
# # # # # # # # # # # # # # # # # # # # # 

physeq.Purp <- subset_samples(physeq.scale, Species == "Ip")
sampledf.Purp<- data.frame(sample_data(physeq.Purp))
# Calculate bray curtis for summer samples only
physeq.Purp.bray <- phyloseq::distance(physeq = physeq.Purp, method = "bray")
amova(physeq.Purp.bray ~ TRT, data = sampledf.Purp) # Across all samples


# # # # # # # # # # # # # # # # # # # # # 
# Subsample for within competition
# # # # # # # # # # # # # # # # # # # # # 

physeq.Comp <- subset_samples(physeq.scale, TRT=="Inter")
sampledf.Comp<- data.frame(sample_data(physeq.Comp))
# Calculate bray curtis for summer samples only
physeq.Comp.bray <- phyloseq::distance(physeq = physeq.Comp, method = "bray")
amova(physeq.Comp.bray ~ Species, data = sampledf.Comp) # marginal species differences

```


## Alpha diversity

```{r alpha diversity,warning=F,comment=F,message=F}
physeq1=prune_samples(sample_sums(physeq) >20000, physeq)
hist(sample_sums(physeq1))
# Remove sample with less than 20K reads, this looks WAAAY off
# Rarify first
ps.rarefied=rarefy_even_depth(physeq1,rngseed=1,sample.size=min(sample_sums(physeq1)),replace=F)

plot_richness(ps.rarefied,x="TRT",measures=c("Observed","Shannon"))+
  geom_boxplot()+
  theme_classic()

```


## Alpha Diversity

#### Note: Measures of alpha-diversity 

_*Inverse Simpson*_ it is an indication of the richness in a community with uniform evenness that would have the same level of diversity. So while measures such as the Shannon index are somewhat abstract, the inverse of the Simpson index has some biological interpretation. Other advantages of the Simpson-based metrics are that they do not tend to be as affected by sampling effort as the Shannon index.
   
- _*Species richness*_ is simply a count of species, and it does not take into account the abundances of the species or their relative abundance distributions.
   
- _*Simpson's Diversity Index*_ is a measure of diversity which takes into account the number of species present, as well as the relative abundance of each species. As species richness and evenness increase,so diversity increases.
```{r Test for significant differences in abundance,warning=F,comment=F,message=F}

sample_data(physeq1)$TRT<-as.factor(sample_data(physeq1)$TRT)
sample_data(physeq1)$Species<-as.factor(sample_data(physeq1)$Species)

# Conver phyloseq object to DESeq data set and run DESeq2

#   ds=phyloseq_to_deseq2(physeq1,~TRT)
#   ds=DESeq(ds)

#Extract the result table from the ds object usind the DESeq2 function results and filter the OTUs using a False Discovery Rate (FDR) cutoff of 0.01. In this example we return the significantly differentially abundant OTU between the treatment

### Function below commented out for efficiency. Saved output as a csv file, and re-open it.

#    alpha=0.01
#    res=results(ds,contrast=c("TRT","Alone","Inter"),alpha=alpha)
    
#    res=res[order(res$padj,na.last=NA),]
#    res_sig=res[(res$padj<alpha),]
#    res_sig # No significant treatment differences


#    ds2=phyloseq_to_deseq2(physeq1,~Species)
#    ds2=DESeq(ds2)
#    alpha=0.01
#    res2=results(ds2,contrast=c("Species","Ip","Ihed"),alpha=alpha)
#    

# Write out to csv files and open them.

#   write.csv(data.frame(res),"Results_Alpha_BetweenTrt.csv",row.names = T)
#   write.csv(data.frame(res2),"Results_Alpha_BetweenSpecies.csv",row.names = T)

resm=read.csv("Results_Alpha_BetweenTrt.csv",row.names = 1)
res2m=read.csv("Results_Alpha_BetweenSpecies.csv",row.names=1)
str(res2m)

alpha=0.01
res2m=res2m[order(res2m$padj,na.last=NA),]
res2m_sig=res2m[(res2m$padj<alpha),]

library(kableExtra)
kable(res2m_sig) # significant species differences in alpha diversity


#The result table reports base means across samples, log2 fold changes, standard errors, test statistics, p-values and adjusted p-values.


res2m_sig = cbind(as(res2m_sig, "data.frame"), as(tax_table(physeq1)[rownames(res2m_sig), ], "matrix"))

colnames(res2m_sig)[7:12]<-c("Kingdom","Phylum","Class","Order","Family","Genus")



ggplot(res2m_sig, aes(x=Phylum, y=log2FoldChange, color=Genus,fill=Genus)) +
geom_point(size=5,alpha=0.5)+
theme(axis.text.x = element_text(angle = -90, hjust = 0, vjust=0.5))+
theme_bw()+
scale_color_brewer(palette = "Paired")+
scale_fill_brewer(palette = "Paired")+
Tx+
theme(axis.text.x = element_text(vjust = 1, hjust=1,size=20,angle=45))
  
  

DifAbund=row.names(res2m_sig)
```


```{r Richness and Inverse Simpson,warning=F,comment=F,message=F}
# Initialize matrices to store richness and Inverse Simpson estimates
nsamp = nsamples(physeq1)
trials = 100

richness <- matrix(nrow = 173, ncol = trials)
row.names(richness) <- sample_names(physeq1)

evenness <- matrix(nrow = 173, ncol = trials)
row.names(evenness) <- sample_names(physeq1)

simpson <- matrix(nrow = 173, ncol = trials)
row.names( simpson) <- sample_names(physeq1)

InvSimp <- matrix(nrow = 173, ncol = trials)
row.names(InvSimp) <- sample_names(physeq1)

shannon <- matrix(nrow = 173, ncol = trials)
row.names(shannon) <- sample_names(physeq1)


### I commented out the subsampling to save time. The matrices produced were saved and then reoponed from their tab delmited formats into corresponding matrices.

set.seed(3)

r <- rarefy_even_depth(physeq1, sample.size = n, verbose = FALSE, replace = TRUE)
         
 ## Calculate richness
rich <- as.numeric(as.matrix(estimate_richness(r, measures = "Observed")))

## Calculate Inverse Simpson

simp <- as.numeric(as.matrix(estimate_richness(r, measures = "InvSimpson")))

sim<- as.numeric(as.matrix(estimate_richness(r, measures = "Simpson")))

s <- rarefy_even_depth(physeq1, sample.size = n, verbose = FALSE, replace = TRUE)
shan <- as.numeric(as.matrix(estimate_richness(r, measures = "Shannon")))

InvSimp=simp

```





```{r}
# Create a new dataframe to hold the means and standard deviations of richness estimates
length(rich)

Sample_ID <- sample_names(physeq1)
Block <-sample_data(physeq1)$Block
Species <-sample_data(physeq1)$Species
TRT <-sample_data(physeq1)$TRT
Combos <-sample_data(physeq1)$Combos
ML <-sample_data(physeq1)$ML

alpha=data.frame(Sample_ID,ML,Block,TRT,Species,Combos,rich,InvSimp,sim,shan)

alpha$even=alpha$shan/alpha$rich

# DO VIOLIN PLOT HERE!!!


p=ggplot(alpha, aes(x=Species, y=rich)) +
  geom_violin(trim=FALSE,aes(fill=Species),alpha=0.3)+ 
  geom_dotplot(binaxis='y', stackdir='center', dotsize=1,aes(color=Species,fill=Species))+
  theme_classic()+
  scale_color_brewer(palette = "Paired")+
  scale_fill_brewer(palette = "Paired")+
  ggtitle("Mean Species Richness")


q=ggplot(alpha, aes(x=Species, y=InvSimp)) +
  geom_violin(trim=FALSE,aes(fill=Species),alpha=0.3)+ 
  geom_dotplot(binaxis='y', stackdir='center', dotsize=1,aes(color=Species,fill=Species))+
  theme_classic()+
  scale_color_brewer(palette = "Paired")+
  scale_fill_brewer(palette = "Paired")+
  ggtitle("Mean Species Inverse Simpson")+
  ylab("")


t=ggplot(alpha, aes(x=Species, y=sim)) +
  geom_violin(trim=FALSE,aes(fill=Species),alpha=0.3)+ 
  geom_dotplot(binaxis='y', stackdir='center', dotsize=1,aes(color=Species,fill=Species))+
  theme_classic()+
  scale_color_brewer(palette = "Paired")+
  scale_fill_brewer(palette = "Paired")+
  ggtitle("Mean Simpson")+
  ylab("")

v=ggplot(alpha, aes(x=Species, y=even)) +
  geom_violin(trim=FALSE,aes(fill=Species),alpha=0.3)+ 
  geom_dotplot(binaxis='y', stackdir='center', dotsize=1,aes(color=Species,fill=Species))+
  theme_classic()+
  scale_color_brewer(palette = "Paired")+
  scale_fill_brewer(palette = "Paired")+
  ggtitle("Mean Evenness")+
  ylab("")



ggarrange(p,q,t,v,common.legend=T,ncol=2,nrow=2)



      ### Treatment

pT=ggplot(alpha, aes(x=TRT, y=rich)) +
  geom_violin(trim=FALSE,aes(fill=TRT),alpha=0.3)+ 
  geom_dotplot(binaxis='y', stackdir='center', dotsize=1,aes(color=TRT,fill=TRT))+
  theme_classic()+
  scale_color_manual(values=c("#B2DF8A","#fee090"))+
  scale_fill_manual(values=c("#B2DF8A","#fee090"))+
  ggtitle("Mean Treatment Richness")


qT=ggplot(alpha, aes(x=TRT, y=InvSimp)) +
  geom_violin(trim=FALSE,aes(fill=TRT),alpha=0.3)+ 
  geom_dotplot(binaxis='y', stackdir='center', dotsize=1,aes(color=TRT,fill=TRT))+
  theme_classic()+
  scale_color_manual(values = c("#B2DF8A","#fee090"))+
  scale_fill_manual(values = c("#B2DF8A","#fee090"))+
  ggtitle("Mean Treatment Inverse Simpson")+
  ylab(" ")

ggarrange(pT,qT,common.legend=T)

```

## Test for differences


```{r ANOVAS on alpha diversities,warning=F,comment=F,message=F}
# first check for normality. To test for normalcy statistically, we can run the Shapiro-Wilk test of normality.

shapiro.test(alpha$rich) # Not normal
shapiro.test(alpha$even) # Normal
shapiro.test(alpha$sim) # Normal

histogram(alpha$rich,xlab="Richness") # Note richness though, not normal, looks close to normal.

histogram(alpha$InvSimp,xlab="Inverse-Simpson")
histogram(alpha$sim,xlab="Simpson")


#   Run the ANOVA and save it as an object
aov.Richness = aov(rich~TRT+Species+Block,alpha)
aov.simpsonInv = aov(InvSimp~TRT+Species+Block,alpha)
aov.simpson = aov(sim~TRT+Species+Block,alpha)
aov.evenness = aov(even~TRT+Species+Block,alpha)
aov.shannon = aov(shan~TRT+Species+Block,alpha)


#Call for the summary of that ANOVA, which will include P-values
summary(aov.Richness)
summary(aov.simpsonInv)
summary(aov.simpson)
summary(aov.evenness)
summary(aov.shannon)

# No significant differences
```


## Plot at phylum level

```{r BarPlot on Phylum,warning=F,comment=F,message=F}

# melt to long format (for ggploting) 
# prune out phyla below 2% in each sample

physeq1_phylum <- physeq1 %>%
  tax_glom(taxrank = "Rank2") %>%                     # agglomerate at phylum level
  transform_sample_counts(function(x) {x/sum(x)} ) %>% # Transform to rel. abundance
  psmelt() %>%                                         # Melt to long format
  filter(Abundance > 0.02)
physeq1_phylum=physeq1_phylum[order(physeq1_phylum$Rank2),] 

#colnames(physeq1_phylum)[13]="Phylum"

# Sort data frame alphabetically by phylum
# Set colors for plotting
phylum_colors <- c(
  "#CBD588", "#5F7FC7", "orange","#DA5724", "#508578", "#CD9BCD",
   "#AD6F3B", "#673770","#D14285", "#652926", "#C84248", 
  "#8569D5", "#5E738F","#D1A33D", "#8A7C64", "#599861"
)


colnames(physeq1_phylum)[which(names(physeq1_phylum)%in%"Rank2")]="Phylum"
# Plot 
ggplot(physeq1_phylum, aes(x = Species, y = Abundance, fill = Phylum)) + 
  geom_bar(stat = "identity") +
  scale_fill_manual(values = phylum_colors)+
  theme(axis.title.x = element_blank()) + 
  ylab("Relative Abundance (Phyla > 2%) \n") +
  ggtitle("Phylum Composition  \n Bacterial Communities by Sampling per Species") +
  theme_classic()+
  ylab("Relative Abundance")

```


## Continous data (root traits, leaf number)
Here, I correlate leaf number to OTUs with at least 5% relative abundance in at least one sample in our data set.

```{r Analyzing leaf data,warning=F,comment=F,message=F}
LeafData<-read.csv("~/Google Drive File Stream/My Drive/Field_2018/Field_2018_Rcode/CharacterDisplacementRootTraits/CleanData/Leaf_Number_SizeProxy_Field2018_7232018.csv")[c("Position","ML","Leaf.Number")]

LeafData$Sample_ID=paste(LeafData$Position,ifelse(grepl("Ihed",LeafData$ML),"H","P"),sep="")
length(which(LeafData$Sample_ID %in% alpha$Sample_ID))


alphadiv2=merge(alpha,LeafData)
dim(alphadiv2) #ok
alphadiv2$Leaf.Number=as.numeric(as.character(alphadiv2$Leaf.Number))

Model1=glm(Leaf.Number~rich+Species+TRT+Block,alphadiv2,family=gaussian())  # Richness
summary(Model1)

Model2=glm(Leaf.Number~InvSimp+Species+TRT+Block,alphadiv2,family=gaussian())  # Inverse Simpson
summary(Model2) # Almost significant inverson simpson effect


Model3=glm(Leaf.Number~sim+Species+TRT+Block,alphadiv2,family=gaussian()) # Simpson
summary(Model3) # 


Model4=glm(Leaf.Number~shan+Species+TRT+Block,alphadiv2,family=gaussian()) # Simpson
summary(Model4) # 

# Correlation test:

alphadiv2Alone=alphadiv2%>%filter(TRT=="Alone")

cor.test(alphadiv2Alone$rich,alphadiv2Alone$Leaf.Number)
cor.test(alphadiv2Alone$sim,alphadiv2Alone$Leaf.Number)
cor.test(alphadiv2Alone$InvSimp,alphadiv2Alone$Leaf.Number)
cor.test(alphadiv2Alone$shan,alphadiv2Alone$Leaf.Number)
cor.test(alphadiv2Alone$even,alphadiv2Alone$Leaf.Number)

alphadiv2Comp=alphadiv2%>%filter(TRT=="Inter")

cor.test(alphadiv2Comp$rich,alphadiv2Comp$Leaf.Number)
cor.test(alphadiv2Comp$sim,alphadiv2Comp$Leaf.Number)
cor.test(alphadiv2Comp$InvSimp,alphadiv2Comp$Leaf.Number)
cor.test(alphadiv2Comp$shan,alphadiv2Comp$Leaf.Number)
cor.test(alphadiv2Comp$even,alphadiv2Comp$Leaf.Number)


## Effect of pcoa beta diversity metric

physeq.pcoa.df$Sample_ID=physeq.pcoa.df$Duplicates
physeq.pcoa.df2=data.frame(merge(physeq.pcoa.df,LeafData))
physeq.pcoa.df2$Leaf.Number=as.numeric(as.character(physeq.pcoa.df2$Leaf.Number))

summary(glm(Leaf.Number~Axis.1+Species+TRT+Block,physeq.pcoa.df2,family=gaussian())) # Axis 1 has marginal effect on leaf number
summary(glm(Leaf.Number~Axis.2+Species+TRT+Block,physeq.pcoa.df2,family=gaussian())) # Axis 2 has a marginal effect on leaf number.
summary(glm(Leaf.Number~Axis.3+Species+TRT+Block,physeq.pcoa.df2,family=gaussian()))
summary(glm(Leaf.Number~Axis.4+Species+TRT+Block,physeq.pcoa.df2,family=gaussian()))
```


```{r Alpha, more estimates,warning=F,comment=F,message=F}

## Additional estimates of alpha diversity
 # Specify a few:
AlphaExtra=estimate_richness(physeq1, measures=c("Observed", "InvSimpson", "Shannon", "Chao1"))
```


## Preliminary test with roots

```{r Preliminary exam on root linear model}
RootData=read.csv("~/Google Drive File Stream/My Drive/Chapter3MicrobiomeMothur/DataSets/MothurOutput_Mock_Microbiome/Microbiome_Output/RootTraits_PCs.csv")

RootAlphaObs=merge(alpha,RootData[c("Sample_ID","PC1","PC2","PC3","PC4")])

SimpPC1=glm(sim~PC1+Species+TRT+Block,RootAlphaObs,family=gaussian()) 
summary(SimpPC1)

SimpInvPC1=glm(InvSimp~PC1+Species+TRT+Block,RootAlphaObs,family=gaussian()) 
summary(SimpInvPC1)

RichPC1=glm(rich~PC1+Species+TRT+Block,RootAlphaObs,family=gaussian()) 
summary(RichPC1)

EvenPC1=glm(even~PC1+Species+TRT+Block,RootAlphaObs,family=gaussian()) 
summary(EvenPC1)


SimpPC2=lm(sim~PC2+Species+TRT+Block,RootAlphaObs) 
summary(SimpPC2) # Marginal effect of Simpson diversity on PC2 (root architecture)

SimpInvPC2=lm(InvSimp~PC2+Species+TRT+Block,RootAlphaObs)
summary(SimpInvPC2) # marginal effect of InvSimp on root architecture SUPER SMALL EFFECT

RichPC2=glm(rich~PC2+Species+TRT+Block,RootAlphaObs,family=gaussian()) 
summary(RichPC2) # Significant mean Richness Effect on root architecture, SUPER small effect size

EvenPC2=glm(even~PC2+Species+TRT+Block,RootAlphaObs,family=gaussian()) 
summary(EvenPC2) # Significant mean Evenness effect--should Check this out it is suspect

### PC3
SimpPC3=glm(sim~PC3+Species+TRT+Block,RootAlphaObs,family=gaussian()) 
summary(SimpPC3) # Marginal effect of species Simpson

SimpInvPC3=glm(InvSimp~PC3+Species+TRT+Block,RootAlphaObs,family=gaussian()) 
summary(SimpInvPC3) # marginal effect of InvSimp on root architecture SUPER SMALL EFFECT

RichPC3=glm(rich~PC3+Species+TRT+Block,RootAlphaObs,family=gaussian()) 
summary(RichPC3)

EvenPC3=glm(even~PC3+Species+TRT+Block,RootAlphaObs,family=gaussian()) 
summary(EvenPC3)

### PC4
SimpPC4=glm(sim~PC4+Species+TRT+Block,RootAlphaObs,family=gaussian()) 
summary(SimpPC4) # Significant Simpson effect

SimpInvPC4=glm(InvSimp~PC4+Species+TRT+Block,RootAlphaObs,family=gaussian()) 
summary(SimpInvPC4)  # Marginal InvSimp effect

RichPC4=glm(rich~PC4+Species+TRT+Block,RootAlphaObs,family=gaussian()) 
summary(RichPC4)

EvenPC4=glm(even~PC4+Species+TRT+Block,RootAlphaObs,family=gaussian()) 
summary(EvenPC4)
```

## Within species (root traits and alphadiv)


```{r Preliminary exam on roots within species}

library(multcomp)

#summary(glht(SimpInvPC1, mcp(rank="Tukey")))

#################################################################
##################### SUBSET for I.purpurea #####################
#################################################################

RootAlphaPurp=droplevels(RootAlphaObs%>%filter(Species=="Ip"))

SimpPC1=glm(sim~PC1+TRT+Block,RootAlphaPurp,family=gaussian()) 
summary(SimpPC1)

SimpInvPC1=lm(InvSimp~PC1+TRT+Block,RootAlphaPurp) 
summary(SimpInvPC1)

RichPC1=lm(rich~PC1+TRT+Block,RootAlphaPurp) 
summary(RichPC1)

EvenPC1=lm(even~PC1+TRT+Block,RootAlphaPurp) 
summary(EvenPC1)


SimpPC2=lm(sim~PC2+TRT+Block,RootAlphaPurp) 
summary(SimpPC2) # Marginal effect of Simpson diversity on PC2 (root architecture)

SimpInvPC2=lm(InvSimp~PC2+TRT+Block,RootAlphaPurp) 
summary(SimpInvPC2) # marginal effect of InvSimp on root architecture SUPER SMALL EFFECT

RichPC2=lm(rich~PC2+TRT+Block,RootAlphaPurp) 
summary(RichPC2) # Significant mean Richness Effect on root architecture, SUPER small effect size

EvenPC2=lm(even~PC2+TRT+Block,RootAlphaPurp) 
summary(EvenPC2) # Significant mean Evenness effect--should Check this out it is suspect

### PC3
SimpPC3=lm(sim~PC2+TRT+Block,RootAlphaPurp) 
summary(SimpPC3) # Marginal effect of species Simpson

SimpInvPC3=lm(InvSimp~PC3+TRT+Block,RootAlphaPurp) 
summary(SimpInvPC3) # marginal effect of InvSimp on root architecture SUPER SMALL EFFECT

RichPC3=lm(rich~PC3+TRT+Block,RootAlphaPurp) 
summary(RichPC3)

EvenPC3=lm(even~PC3+TRT+Block,RootAlphaPurp) 
summary(EvenPC3)

### PC4
SimpPC4=lm(sim~PC4+TRT+Block,RootAlphaPurp) 
summary(SimpPC4) # Significant Simpson effect

SimpInvPC4=lm(InvSimp~PC4+TRT+Block,RootAlphaPurp) 
summary(SimpInvPC4)  # Marginal InvSimp effect

RichPC4=lm(rich~PC4+TRT+Block,RootAlphaPurp) 
summary(RichPC4)

EvenPC4=lm(even~PC4+TRT+Block,RootAlphaPurp) 
summary(EvenPC4)

```

## Plotting significant linear associations
```{r Preliminary exam on roots maternal line variation}

# Richness
P2.rich=ggscatter(RootAlphaObs, x = "PC2", y = "rich",
   color = "black", shape = 21, size = 3, # Points color, shape and size
   add = "reg.line",  # Add regressin line
   add.params = list(color = "blue", fill = "lightgray"), # Customize reg. line
   conf.int = TRUE, # Add confidence interval
   cor.coef = TRUE, # Add correlation coefficient. see ?stat_cor
   cor.coeff.args = list(method = "pearson", label.x = 2, label.sep = "\n"),
   cor.coef.size = 6
   )+
  ylab("Richness")+
  Tx+ 
  scale_y_continuous(labels = function(x) format(x, scientific = T))

P2.sim=ggscatter(RootAlphaObs, x = "PC2", y = "sim",
   color = "black", shape = 21, size = 3, # Points color, shape and size
   add = "reg.line",  # Add regressin line
   add.params = list(color = "blue", fill = "lightgray"), # Customize reg. line
   conf.int = TRUE, # Add confidence interval
   cor.coef = TRUE, # Add correlation coefficient. see ?stat_cor
   cor.coeff.args = list(method = "pearson", label.x = 3,label.y = .99, label.sep = "\n"),
   cor.coef.size = 6
   )+
  ylab("Simpson")+
  Tx+ 
  scale_y_continuous(labels = function(x) format(x, scientific = T))

P2.InSim=ggscatter(RootAlphaObs, x = "PC2", y = "InvSimp",
   color = "black", shape = 21, size = 3, # Points color, shape and size
   add = "reg.line",  # Add regressin line
   add.params = list(color = "blue", fill = "lightgray"), # Customize reg. line
   conf.int = TRUE, # Add confidence interval
   cor.coef = TRUE, # Add correlation coefficient. see ?stat_cor
   cor.coeff.args = list(method = "pearson", label.x = 2, label.sep = "\n"),
   cor.coef.size = 6
   )+
  ylab("Inverse Simpson")+
  Tx+ 
  scale_y_continuous(labels = function(x) format(x, scientific = T))
    
P2.even=ggscatter(RootAlphaObs, x = "PC2", y = "even",
   color = "black", shape = 21, size = 3, # Points color, shape and size
   add = "reg.line",  # Add regressin line
   add.params = list(color = "blue", fill = "lightgray"), # Customize reg. line
   conf.int = TRUE, # Add confidence interval
   cor.coef = TRUE, # Add correlation coefficient. see ?stat_cor
   cor.coeff.args = list(method = "pearson", label.x = 2, label.sep = "\n"),
   cor.coef.size = 6
   ) +
  ylab("Evenness")+
  Tx+ 
  scale_y_continuous(labels = function(x) format(x, scientific = T))
    
ggarrange(P2.rich,P2.sim,P2.InSim,P2.even)

# Root morphology on species diversity Simpson metric
P4.sim=ggscatter(RootAlphaObs, x = "PC4", y = "sim",
   color = "black", shape = 21, size = 3, # Points color, shape and size
   add = "reg.line",  # Add regressin line
   add.params = list(color = "blue", fill = "lightgray"), # Customize reg. line
   conf.int = TRUE, # Add confidence interval
   cor.coef = TRUE, # Add correlation coefficient. see ?stat_cor
   cor.coeff.args = list(method = "pearson", label.y=0.999,label.x = 2, label.sep = "\n"),
   cor.coef.size = 6
   ) +
  ylab("Simpson")+
  Tx+ 
  scale_y_continuous(labels = function(x) format(x, scientific = T))
 
```

## Linear mixed models
```{r}
library(lmerTest)

### Simpson
SimpLMM=lmer(sim~Species+TRT+Block+(1|ML)+(1|Combos),alpha) 
anova(SimpLMM)
ranova(SimpLMM)

### Inverse Simpson
SimpInvLMM=lmer(mean~Species+TRT+Block+(1|ML)+(1|Combos),alpha) 
anova(SimpInvLMM)
ranova(SimpInvLMM)

### Inverse Simpson
RichLMM=lmer(mean~Species+TRT+Block+(1|ML)+(1|Combos),alpha) 
anova(RichLMM)
ranova(RichLMM)

# Bray curtis metric now


Ax1LMM=lmer(Axis.1~Species+TRT+Block+(1|ML),physeq.pcoa.df)
anova(Ax1LMM)
ranova(Ax1LMM)


Ax2LMM=lmer(Axis.2~Species+TRT+Block+(1|ML),physeq.pcoa.df)
anova(Ax2LMM) # Significant species diffeences in axis 2
ranova(Ax2LMM)


Ax3LMM=lmer(Axis.3~Species+TRT+Block+(1|ML),physeq.pcoa.df)
anova(Ax3LMM) 
ranova(Ax3LMM)

Ax4LMM=lmer(Axis.4~Species+TRT+Block+(1|ML),physeq.pcoa.df)
anova(Ax4LMM) # Marginal species differences
ranova(Ax4LMM)
```


```{r Read in fitness data}
Fitness=read.csv("~/Google Drive File Stream/My Drive/Field_2018/Field_2018_Rcode/CharacterDisplacementRootTraits/CleanData/FitPA4.csv")

# Calculate relative fitness
  # First calculate mean seed number by species and treatment---note* we only have seed output of I. purpurea
MeanSeedNumber=Fitness%>%
  group_by(Species,Trt)%>%
  summarise("MeanSeedNumber"=mean(SeedNumber))

Ipurp.Fit=Fitness%>%
  filter(Species=="Ip")

Ipurp.Alpha=alphadiv%>%
  filter(Species=="Ip")

FitnessPurp=merge(Ipurp.Fit,MeanSeedNumber)
FitnessPurp$RelativeFit=FitnessPurp$SeedNumber/FitnessPurp$MeanSeedNumber
FitnessPurp$Block=as.factor(FitnessPurp$Block)

ggplot(FitnessPurp,aes(Trt,RelativeFit,fill=Block))+
  geom_boxplot()+
  scale_fill_brewer("Paired")+
  theme_classic()+
  ylab("Relative Fitness")+
  ggtitle("Relative Fitness by Treatment and Block")

```

```{r phenotypic selection}

####  ####  ####  ####  ####  ####   ####
#  Examine selection on microbiome first
####  ####  ####  ####  ####  ####   ####
FitnessPurp$TRT=FitnessPurp$Trt
FitnessPurp$Combos=as.character(FitnessPurp$Combos)
FitnessPurp[which(FitnessPurp$Trt=="Alone"),]$Combos="none"
FitnessPurp$Combos=as.factor(FitnessPurp$Combos)

BrayFit=merge(physeq.pcoa.df,FitnessPurp)

FitAlpha=merge(FitnessPurp,alpha)
dim(FitAlpha)

Alone=FitAlpha%>%
  filter(TRT=="Alone")

Comp=FitAlpha%>%
  filter(TRT!="Alone")

# Combine with root data
library(dplyr)

RootAveraged=RootData%>%
  group_by(Species,ML,Combos,Trt,Block)%>%
  summarise("PC1"=mean(PC1,na.rm=T),"PC2"=mean(PC2,na.rm=T),"PC3"=mean(PC3,na.rm=T),"PC4"=mean(PC4,na.rm=T))


RootFitAlpha=merge(FitAlpha,RootAveraged)
head(RootFitAlpha)

Alone=RootFitAlpha%>%
  filter(TRT=="Alone")

Comp=RootFitAlpha%>%
  filter(TRT!="Alone")


# Subset bray and fintess by treatment
Alone2=BrayFit%>%
  filter(TRT=="Alone")

Comp2=BrayFit%>%
  filter(TRT!="Alone")

# Combina root, fitness/bray estimates
RootFitBray=merge(BrayFit,RootAveraged)

```

### Selection on richness
```{r selection on richness within Alone}
Alone.richness_sel=lm(RelativeFit~rich,Alone)

summary(Alone.richness_sel) # No evidence of indirect selection
```

```{r selection on richness within competition}
Comp.richness_sel=lm(RelativeFit~rich,Comp)

summary(Comp.richness_sel) # No evidence of indirect selection
```


### Selection on Evenness
```{r selection on evenness within Alone}
Alone.evenness_sel=lm(RelativeFit~even,Alone)

summary(Alone.evenness_sel) # No evidence of indirect selection
```

```{r selection on evenness within competition}
Comp.evenness_sel=lm(RelativeFit~even,Comp)

summary(Comp.evenness_sel) # No evidence of indirect selection
```

### Selection on inverse simpson

```{r selection on Inverse Simpson within Alone}
Alone.Inv_Simp_sel=lm(RelativeFit~InvSimp,Alone)

summary(Alone.Inv_Simp_sel) # No evidence of indirect selection
```

```{r selection on Inverse Simpson within competition}
Comp.Invn_sel=lm(RelativeFit~InvSimp,Comp)

summary(Comp.Invn_sel) # No evidence of indirect selection
```


### Selection on Simpson index

```{r selection on simpson within Alone}
Alone.simpson_sel=lm(RelativeFit~sim,Alone)

summary(Alone.simpson_sel) # No evidence of indirect selection
```

```{r selection on simpson within competition}
Comp.simpson_sel=lm(RelativeFit~sim,Comp)

summary(Comp.simpson_sel) # No evidence of indirect selection
```

### Selection on Bray curtis estimates


### Axis 1
```{r Axis 1 Bray selection on richness within Alone2}
Alone2_sel=lm(RelativeFit~Axis.1,Alone2)
summary(Alone2_sel) # No evidence of indirect selection
```

```{r Axis 1 Bray selection on richness within Comp2etition}
Comp2_sel=lm(RelativeFit~Axis.1,Comp2)
summary(Comp2_sel) # Evidence of indirect selection
```

### Axis 2
```{r Axis 2 Bray selection on richness within Alone2}
Alone2_sel=lm(RelativeFit~Axis.2,Alone2)
summary(Alone2_sel) # No evidence of indirect selection
```

```{r Axis 2 Bray selection on richness within Comp2etition}
Comp2_sel=lm(RelativeFit~Axis.2,Comp2)
summary(Comp2_sel) # No evidence of indirect selection
```


### Axis 3
```{r Axis 3 Bray selection on richness within Alone2}
Alone2_sel=lm(RelativeFit~Axis.3,Alone2)
summary(Alone2_sel) # No evidence of indirect selection
```

```{r Axis 3 Bray selection on richness within Comp2etition}
Comp2_sel=lm(RelativeFit~Axis.3,Comp2)
summary(Comp2_sel) # No evidence of indirect selection
```

### Axis 4
```{r Axis 4 Bray selection on richness within Alone2}
Alone2_sel=lm(RelativeFit~Axis.4,Alone2)
summary(Alone2_sel) # Evidence of selection on Axis 4
```

```{r Axis 4 Bray selection on richness within Comp2etition}
Comp2_sel=lm(RelativeFit~Axis.4,Comp2)
summary(Comp2_sel) # No evidence of indirect selection
```


## Correlative selection root phenotype and microbe variables


### Selection on richness
```{r cor selection on richness within Alone}
PC1.Alone.richness_sel=lm(RelativeFit~PC1*rich,Alone)
summary(PC1.Alone.richness_sel) # No evidence of indirect selection

PC1.Comp.richness_sel=lm(RelativeFit~PC1*rich,Comp)
summary(PC1.Comp.richness_sel) 


PC2.Alone.richness_sel=lm(RelativeFit~PC2*rich,Alone)
summary(PC2.Alone.richness_sel) # No evidence of indirect selection

PC2.Comp.richness_sel=lm(RelativeFit~PC2*rich,Comp)
summary(PC2.Comp.richness_sel) 

PC3.Alone.richness_sel=lm(RelativeFit~PC3*rich,Alone)
summary(PC3.Alone.richness_sel) # No evidence of indirect selection

PC3.Comp.richness_sel=lm(RelativeFit~PC3*rich,Comp)
summary(PC3.Comp.richness_sel) 

PC4.Alone.richness_sel=lm(RelativeFit~PC4*rich,Alone)
summary(PC4.Alone.richness_sel) # No evidence of indirect selection

PC4.Comp.richness_sel=lm(RelativeFit~PC4*rich,Comp)
summary(PC4.Comp.richness_sel) 
```




### Selection on Inverse Simpson
```{r cor selection on Inverse Simpson within Alone}
PC1.Alone.Invn_sel=lm(RelativeFit~PC1*InvSimp,Alone)
summary(PC1.Alone.Invn_sel) # No evidence of indirect selection

PC1.Comp.Invn_sel=lm(RelativeFit~PC1*InvSimp,Comp)
summary(PC1.Comp.Invn_sel) 


PC2.Alone.Invn_sel=lm(RelativeFit~PC2*InvSimp,Alone)
summary(PC2.Alone.Invn_sel) # No evidence of indirect selection

PC2.Comp.Invn_sel=lm(RelativeFit~PC2*InvSimp,Comp)
summary(PC2.Comp.Invn_sel) 

PC3.Alone.Invn_sel=lm(RelativeFit~PC3*InvSimp,Alone)
summary(PC3.Alone.Invn_sel) # No evidence of indirect selection

PC3.Comp.Invn_sel=lm(RelativeFit~PC3*InvSimp,Comp)
summary(PC3.Comp.Invn_sel) 

PC4.Alone.Invn_sel=lm(RelativeFit~PC4*InvSimp,Alone)
summary(PC4.Alone.Invn_sel) # No evidence of indirect selection

PC4.Comp.Invn_sel=lm(RelativeFit~PC4*InvSimp,Comp)
summary(PC4.Comp.Invn_sel)  # Selecion on root morphology only
```


```{r cor selection on Simpson within Alone}
PC1.Alone.Simpson_sel=lm(RelativeFit~PC1*sim,Alone)
summary(PC1.Alone.Simpson_sel) # No evidence of indirect selection

PC1.Comp.Simpson_sel=lm(RelativeFit~PC1*sim,Comp)
summary(PC1.Comp.Simpson_sel) 


PC2.Alone.Simpson_sel=lm(RelativeFit~PC2*sim,Alone)
summary(PC2.Alone.Simpson_sel) # No evidence of indirect selection

PC2.Comp.Simpson_sel=lm(RelativeFit~PC2*sim,Comp)
summary(PC2.Comp.Simpson_sel) 

PC3.Alone.Simpson_sel=lm(RelativeFit~PC3*sim,Alone)
summary(PC3.Alone.Simpson_sel) # No evidence of indirect selection

PC3.Comp.Simpson_sel=lm(RelativeFit~PC3*sim,Comp)
summary(PC3.Comp.Simpson_sel) 

PC4.Alone.Simpson_sel=lm(RelativeFit~PC4*sim,Alone)
summary(PC4.Alone.Simpson_sel) # No evidence of indirect selection

PC4.Comp.Simpson_sel=lm(RelativeFit~PC4*sim,Comp)
summary(PC4.Comp.Simpson_sel) 
```

### Correlative Selection on Bray curtis
```{r Axis 1 cor Bray curtis selection }
Alone2B=RootFitBray%>%filter(Trt=="Alone")
Comp2B=RootFitBray%>%filter(Trt=="Inter")


PC1.Alone=lm(RelativeFit~PC1*Axis.1,Alone2B)
summary(PC1.Alone) # No evidence of indirect selection

PC1.Comp=lm(RelativeFit~PC1*Axis.1,Comp2B)
summary(PC1.Comp) # Marginal selection on axis 1

PC2.Alone=lm(RelativeFit~PC2*Axis.1,Alone2B)
summary(PC2.Alone) # No evidence of indirect selection

PC2.Comp=lm(RelativeFit~PC2*Axis.1,Comp2B)
summary(PC2.Comp) # Significant effect of Axis.1 

PC3.Alone=lm(RelativeFit~PC3*Axis.1,Alone2B)
summary(PC3.Alone) #Marginal effect of axis 1

PC3.Comp=lm(RelativeFit~PC3*Axis.1,Comp2B)
summary(PC3.Comp) # significant effect of axis 1

PC4.Alone=lm(RelativeFit~PC4*Axis.1,Alone2B)
summary(PC4.Alone) # No evidence of indirect selection

PC4.Comp=lm(RelativeFit~PC4*Axis.1,Comp2B)
summary(PC4.Comp) # Significant effect of axis 1
```

```{r Axis 2 cor Bray curtis selection }
PC1.Alone=lm(RelativeFit~PC1*Axis.2,Alone2B)
summary(PC1.Alone) # No evidence of indirect selection

PC1.Comp=lm(RelativeFit~PC1*Axis.2,Comp2B)
summary(PC1.Comp)

PC2.Alone=lm(RelativeFit~PC2*Axis.2,Alone2B)
summary(PC2.Alone) # No evidence of indirect selection

PC2.Comp=lm(RelativeFit~PC2*Axis.2,Comp2B)
summary(PC2.Comp) # Marginal effect of root architecture by Axis.2 interaction

PC3.Alone=lm(RelativeFit~PC3*Axis.2,Alone2B)
summary(PC3.Alone) 

PC3.Comp=lm(RelativeFit~PC3*Axis.2,Comp2B)
summary(PC3.Comp) 

PC4.Alone=lm(RelativeFit~PC4*Axis.2,Alone2B)
summary(PC4.Alone) # No evidence of indirect selection

PC4.Comp=lm(RelativeFit~PC4*Axis.2,Comp2B)
summary(PC4.Comp) 
```

```{r Axis 3 cor Bray curtis selection }
PC1.Alone=lm(RelativeFit~PC1*Axis.3,Alone2B)
summary(PC1.Alone) # No evidence of indirect selection

PC1.Comp=lm(RelativeFit~PC1*Axis.3,Comp2B)
summary(PC1.Comp)

PC2.Alone=lm(RelativeFit~PC2*Axis.3,Alone2B)
summary(PC2.Alone) # No evidence of indirect selection

PC2.Comp=lm(RelativeFit~PC2*Axis.3,Comp2B)
summary(PC2.Comp) # Marginal effect of root architecture by Axis.3 interaction

PC3.Alone=lm(RelativeFit~PC3*Axis.3,Alone2B)
summary(PC3.Alone) 

PC3.Comp=lm(RelativeFit~PC3*Axis.3,Comp2B)
summary(PC3.Comp) 

PC4.Alone=lm(RelativeFit~PC4*Axis.3,Alone2B)
summary(PC4.Alone) # No evidence of indirect selection

PC4.Comp=lm(RelativeFit~PC4*Axis.3,Comp2B)
summary(PC4.Comp) # Marginal effect of Axis 3 on fitness
```

```{r Axis 4 cor Bray curtis selection }
PC1.Alone=lm(RelativeFit~PC1*Axis.4,Alone2B)
summary(PC1.Alone) # No evidence of indirect selection

PC1.Comp=lm(RelativeFit~PC1*Axis.4,Comp2B)
summary(PC1.Comp)

PC2.Alone=lm(RelativeFit~PC2*Axis.4,Alone2B)
summary(PC2.Alone) # SIGNIFICANT effect of Axis.4 on relative fitness

PC2.Comp=lm(RelativeFit~PC2*Axis.4,Comp2B)
summary(PC2.Comp) 

PC3.Alone=lm(RelativeFit~PC3*Axis.4,Alone2B)
summary(PC3.Alone) 

PC3.Comp=lm(RelativeFit~PC3*Axis.4,Comp2B)
summary(PC3.Comp) 

PC4.Alone=lm(RelativeFit~PC4*Axis.4,Alone2B)
summary(PC4.Alone) # Significant effect of Axis.4 on fitness 

PC4.Comp=lm(RelativeFit~PC4*Axis.4,Comp2B)
summary(PC4.Comp) 
```

## ANCOVAs
```{r Test for evidence of treatment impacting selection}
# Test for Bray curtis AXIS 1 AND 4

anova(lm(RelativeFit~Axis.1*Trt+Block,BrayFit))
anova(lm(RelativeFit~Axis.2*Trt+Block,BrayFit))
anova(lm(RelativeFit~Axis.3*Trt+Block,BrayFit))
anova(lm(RelativeFit~Axis.4*Trt+Block,BrayFit))


```

```{r Selection plots alpha measurements}

BrayFit$Treatment=ifelse(BrayFit$TRT=="Inter","Competition","Alone")



Selec_Axis1=ggplot(BrayFit,aes(Axis.1,RelativeFit))+
        stat_smooth(method="lm",se=F,aes(color=Treatment),size=2)+
        #geom_abline(intercept=0.96921,slope=1.12134,color="red",size=2)+
        #geom_abline(intercept=0.89466,slope=0.56063,color="darkblue",size=2)+
        geom_point(aes(color=Treatment),alpha=0.6,size=3)+
        #scale_color_manual(values = c("darkorange","lightgrey"))+
        scale_color_calc()+
        theme_classic()+
        xlab("Axis 1")+
        ylab("")+
        Tx


Selec_Axis4=ggplot(BrayFit,aes(Axis.4,RelativeFit))+
        stat_smooth(method="lm",se=F,aes(color=Treatment),size=2)+
        #geom_abline(intercept=0.87567,slope=3.56669,color="red",size=2)+
        #geom_abline(intercept=0.99413,slope=0.54733,color="darkblue",size=2)+
        geom_point(aes(color=Treatment),alpha=0.6,size=3)+
        #scale_color_manual(values = c("darkorange","lightgrey"))+
        scale_color_calc()+
        theme_classic()+
        xlab("Axis 4")+
        ylab("")+
        Tx


figure=ggarrange(Selec_Axis1,Selec_Axis4,ncol=2,common.legend = T)

# Annotate the figure by adding a common labels
annotate_figure(figure,
                top = text_grob("", color = "red", face = "bold", size = 25),
                bottom = text_grob("Bray Curtis Diversity Index PCoA",size = 25),
                left = text_grob("Relative Fitness", rot = 90, size=25),
                fig.lab = "", fig.lab.face = "bold"
)

```



```{r, warning=F,comment=F,message=F}

# Create data frame with OTU's that had different abundance 
DifAbund1=data.frame(t(otu_table(physeq1)[row.names(otu_table(physeq1))%in%DifAbund,]))
DifAbund1$Sample_ID=as.factor(row.names(DifAbund1))
DifAbund1=merge(DifAbund1,data.frame(sampledata))

# Estimate their 'relative abundances' 
MeanSeqNum=mean(sample_sums(physeq1)) # Mean sequence count
DifAbunRel=DifAbund1

DivideByMeanSeq=function(x){x/MeanSeqNum} # Function to divide by mean sequence number

DifAbunRel[grep("Otu",colnames(DifAbund1))]=DivideByMeanSeq(DifAbunRel[grep("Otu",colnames(DifAbund1))]) # Apply function and over write count numbers by their relative abundance value
DifAbunReFit=merge(FitnessPurp[c("Species","TRT","ML","Combos","Comp","RelativeFit","Block")],DifAbunRel)

# Examine correlation between OTU's and leaf number by Species

Cor1=rcorr(as.matrix(DifAbunReFit[grep("Otu|Fit",names(DifAbunReFit))]))

corrplot(Cor1$r,type="upper")

# Display significance
# Mark the insignificant coefficients according to the specified p-value significance level

col <- colorRampPalette(c("#BB4444", "#EE9988", "#FFFFFF", "#77AADD", "#4477AA"))
C1=corrplot(Cor1$r, type = "upper",
         p.mat = Cor1$P, sig.level = 0.05, tl.col = "black", col=col(200))

plot(DifAbunReFit$Otu00284,DifAbunReFit$RelativeFit)

DifModel=lm(RelativeFit~.,data=DifAbunReFit[grep("Otu|Fit",names(DifAbunReFit))])
summary(DifModel)


DifModelA=lm(RelativeFit~.,data=(DifAbunReFit[grep("Otu|Fit",names(DifAbunReFit))])%>%filter(Otu00284<0.003)) # Removal of outlier strengthens the linear effect
summary(DifModelA)

DifModelAlone=lm(RelativeFit~Block+Otu00284,data=(DifAbunReFit[grep("Otu|Fit|TRT|Block",names(DifAbunReFit))])%>%filter(TRT=="Alone"))
summary(DifModelAlone)

DifModelComp=lm(RelativeFit~Block+Otu00284,data=DifAbunReFit%>%filter(TRT!="Alone",Otu00284<0.003))
summary(DifModelComp)

DifModel2=lm(RelativeFit~TRT*Block+Otu00284+Otu00284:TRT,data=DifAbunReFit%>%filter(Otu00284<0.003))
summary(DifModel2)



V1=ggplot(DifAbunReFit,aes(x = Otu00284,y = RelativeFit,colour=TRT))+
  geom_point(aes(color=TRT))+
  geom_smooth(method = "lm")+
  theme_bw()+
  Tx+
  geom_vline(xintercept = 0.003,linetype="dotted",color="red")

V2=ggplot(DifAbunReFit%>%filter(Otu00284<0.003),aes(x = Otu00284,y = RelativeFit,colour=TRT))+
  geom_point(aes(color=TRT))+
  geom_smooth(method = "lm")+
  theme_bw()+
  Tx

ggarrange(V1,V2,common.legend = T)
  
  V1+
    ylab("Relative Fitness")+
    xlab("Otu00284 relative abundance")+
    scale_color_manual(values = c("gold","black"))+
      geom_vline(xintercept = 0.003,linetype="dashed",color="red")

  

A=ggplot(DifAbunReFit%>%filter(Species=="Ip"),aes(Otu00290,Leaf.Number))+
  geom_point(aes(color=TRT),shape=1,size=2)+
  geom_smooth(method = lm)+
  theme_classic()+
  scale_colour_manual(values = c("gold","black"))+
  ylab("Leaf Number")


A2=ggplot(DifAbunReFit%>%filter(Species=="Ihed"),aes(Otu00290,Leaf.Number))+
  geom_point(shape=1,size=2)+
  geom_smooth(method = lm)+
  theme_classic()+
  ylab("Leaf Number")

ggarrange(A,A2,common.legend = T)

cor.test(Otu.Ip$Leaf.Number,Otu.Ip$Otu00290)
```


# Correlation between OTUs & PCoA Axes 1-4
```{r}
# Combine PCOA data, leaf data and Otu diff abundant data

combined1=merge(physeq.pcoa.df,DifAbunReFit)

dim(combined1)

Matrix1=as.matrix(combined1[grep("Axis|Otu",names(combined1))])

head(Matrix1)

Cor3=rcorr(Matrix1)

corrplot(Cor3$r,type="upper")

# Display significance
# Mark the insignificant coefficients according to the specified p-value significance level

corrplot(Cor3$r, type = "upper", 
         p.mat = Cor3$P, sig.level = 0.05)

```




# MANTEL test to examine how microbiome disimilarity is correlated with relative fitness
```{r,include=F,render=F}

# Load matrix Bray distances of OTU abundance
OTU_table=t(otu_table(physeq1)) # Write out OTU table

# Average root traits by maternal line, treatment and block
AvMLBkRoots=RootData%>%
  group_by(Species,ML,Trt,Block)%>%
  summarise("PC1"=mean(PC1,na.rm=T),"PC2"=mean(PC2,na.rm=T),"PC3"=mean(PC3,na.rm=T),"PC4"=mean(PC4,na.rm=T))
colnames(AvMLBkRoots)[3]="TRT"


# Pull out Root traits of interest and save these to the Sampled data frame
SampledRoots=merge(AvMLBkRoots,sampledf,by=c("TRT","Species","ML","Block"))


OTU_table=OTU_table[row.names(OTU_table)%in%SampledRoots$Sample_ID,]
write.csv(OTU_table,"OTU_table.csv",row.names = T) # Save OTU table re-open in great lakes computing for mantel test

write.csv(SampledRoots,"RootFamilyBlockAverage.csv",row.names=F)

# GREAT LAKE COMMANDS

# Read in data
    #OTU=read.csv("OTU_table.csv")
    #Roots=read.csv("RootFamilyBlockAverage.csv")

# Calculate root architecture distances with euclidean distance 

    #PC2=Roots$PC2 # isolate PC2, i.e. root architecture
    # PC2.dist=dist(PC2)

# Calculate Bray distance matrix for OTU table

    #  Bray=vegdist(OTU[-1],method="bray")

# OTU Bray vs Root architecture

    # OTU_pc2 = mantel(Bray, PC2.dist, method = "spearman", permutations = 9999, na.rm = TRUE)

# Reapat for root topology, size and morphology

  # PC1=Roots$PC1 # isolate 
  # PC1.dist=dist(PC1)
  # PC3=Roots$PC3 # isolate 
  # PC3.dist=dist(PC3)
  # PC4=Roots$PC1 # isolate 
  # PC4.dist=dist(PC4)

# Examine overall distances in root system; i.e. use all PCs in distance calculation

    # PCall=Roots[grep("PC",names(Roots))]
    # PC.dist=dist(PCall)

    # OTU_pc = mantel(Bray, PC.dist, method = "spearman", permutations = 9999, na.rm = TRUE)

###             examine mantel test using observed values of roots ###

OTU_sub=OTU_table[which(row.names(OTU_table)%in%RootAlphaObs$Sample_ID),]
BraySub=vegdist(OTU_sub,method="bray")
SampledRoots.sub=SampledRoots[which(SampledRoots$Sample_ID%in%RootAlphaObs$Sample_ID),]

PC1.sub=SampledRoots.sub$PC1
PC2.sub=SampledRoots.sub$PC2
PC3.sub=SampledRoots.sub$PC3
PC4.sub=SampledRoots.sub$PC4

dist.PC1.sub=dist(PC1.sub)
dist.PC2.sub=dist(PC2.sub)
dist.PC3.sub=dist(PC3.sub)
dist.PC4.sub=dist(PC4.sub)
dist.PC.sub=dist(SampledRoots.sub[grep("PC",names(SampledRoots.sub))])


OTU_pc1 = mantel(BraySub,dist.PC1.sub, method = "spearman", permutations = 9999, na.rm = TRUE)
OTU_pc2 = mantel(BraySub,dist.PC2.sub, method = "spearman", permutations = 9999, na.rm = TRUE)
OTU_pc3 = mantel(BraySub,dist.PC3.sub, method = "spearman", permutations = 9999, na.rm = TRUE)
OTU_pc4 = mantel(BraySub,dist.PC4.sub, method = "spearman", permutations = 9999, na.rm = TRUE)
OTU_pc = mantel(BraySub,dist.PC.sub, method = "spearman", permutations = 9999, na.rm = TRUE)
```



