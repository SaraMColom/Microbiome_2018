# Significant PC2:InvSimp:TRT:Block
# Marginal InvSimp:TRT:Block
# PC3 and Inv Sipm
anova(lm(RelativeFitness~PC3*InvSimp*TRT+Block,RootFitAlpha))
summary(InvSimpPC3) #Significant
# Within treatment regressions
InvSimpPC3Alone=lm(RelativeFitness~PC3*InvSimp*Comp+Block,RootFitAlpha%>%filter(TRT=="Alone"))
summary(InvSimpPC3Alone)
InvSimpPC3Comp=lm(RelativeFitness~PC3*InvSimp+Block,RootFitAlpha%>%filter(TRT!="Alone"))
summary(InvSimpPC3Comp)
# Inv simp and PC4
summary(lm(RelativeFitness~PC4*InvSimp+Block,RootFitAlpha%>%filter(TRT=="Alone")))
summary(lm(RelativeFitness~PC4*InvSimp+Block,RootFitAlpha%>%filter(TRT!="Alone")))
anova(lm(RelativeFitness~PC4*InvSimp*TRT*Block,RootFitAlpha))
# Significant PC4
# Significant InvSimp
# Significant Block
# Significant PC4:Block
# Significant InvSimp:TRT:Block
# Even and PC1
summary(lm(RelativeFitness~PC1*even+Block,RootFitAlpha%>%filter(TRT=="Alone")))
summary(lm(RelativeFitness~PC1*even+Block,RootFitAlpha%>%filter(TRT!="Alone")))
anova(lm(RelativeFitness~PC1*even*TRT*Block,RootFitAlpha))
# Marginal PC1:even:Block
# Significant PC1:TRT:Block
# Significant PC1:Block
# Significant even
# Significant Block
# Even and PC2
summary(lm(RelativeFitness~PC2*even+Block,RootFitAlpha%>%filter(TRT=="Alone")))
summary(lm(RelativeFitness~PC2*even+Block,RootFitAlpha%>%filter(TRT!="Alone")))
anova(lm(RelativeFitness~PC2*even*TRT*Block,RootFitAlpha))
# Significant even
# Significant Treatment
# Significant Block
# Significant PC2:TRT:Block
# Significant PC2:even:TRT:Block
# Even and PC3
summary(lm(RelativeFitness~PC3*even+Block,RootFitAlpha%>%filter(TRT=="Alone")))
summary(lm(RelativeFitness~PC3*even+Block,RootFitAlpha%>%filter(TRT!="Alone")))
anova(lm(RelativeFitness~PC3*even*TRT*Block,RootFitAlpha))
# Significant even
# Significant Block
# Significant TRT:Block
# Significant PC3:even:Block
# Marginal PC3:TRT:Block
# Even and PC4
summary(lm(RelativeFitness~PC4*even+Block,RootFitAlpha%>%filter(TRT=="Alone")))
summary(lm(RelativeFitness~PC4*even+Block,RootFitAlpha%>%filter(TRT!="Alone")))
anova(lm(RelativeFitness~PC4*even*TRT*Block,RootFitAlpha))
# Significant even
# Significant PC4
# Marginal TRT
# Significant Block
# PC4:Block
# Marginal Block:TRT
# Significant PC4:even:TRT:Block
# Chunk 34
# Here I use observed values of root traits
# Load matrix Bray distances of OTU abundance
OTU_table=t(otu_table(physeq1)) # Write out OTU table
# Pull out Root traits of interest and save these to the Sampled data frame
SampledRoots=merge(RootAlphaObs,sampledf)
OTU_table=OTU_table[row.names(OTU_table)%in%SampledRoots$Sample_ID,]
OTU=OTU_table
Roots=SampledRoots
# Calculate root architecture distances with euclidean distance
PC2=Roots$PC2 # isolate PC2, i.e. root architecture
PC2.dist=dist(PC2)
# Calculate Bray distance matrix for OTU table
Bray=vegdist(OTU,method="bray")
# OTU Bray vs Root architecture
OTU_pc2 = mantel(Bray, PC2.dist, method = "spearman", permutations = 9999, na.rm = TRUE)
# Marginally significant--very low r value
# Mantel statistic r: 0.03795
# Significance: 0.1166
# Reapat for root topology, size and morphology
PC1=Roots$PC1 # isolate
PC1.dist=dist(PC1)
PC3=Roots$PC3 # isolate
PC3.dist=dist(PC3)
PC4=Roots$PC1 # isolate
PC4.dist=dist(PC4)
# Examine overall distances in root system; i.e. use all PCs in distance calculation
PCall=Roots[grep("PC",names(Roots))]
PC.dist=dist(PCall)
OTU_pc = mantel(Bray, PC.dist, method = "spearman", permutations = 9999, na.rm = TRUE)
###             examine mantel test using observed values of roots ###
OTU_pc1 = mantel(Bray,PC1.dist, method = "spearman", permutations = 9999, na.rm = TRUE)
OTU_pc2 = mantel(Bray,PC2.dist, method = "spearman", permutations = 9999, na.rm = TRUE)
OTU_pc3 = mantel(Bray,PC3.dist, method = "spearman", permutations = 9999, na.rm = TRUE)
OTU_pc4 = mantel(Bray,PC4.dist, method = "spearman", permutations = 9999, na.rm = TRUE)
# Repeat but standardize for Block
Standardize=function(x,data){
StandData=residuals(lm(x~Block,data))
return(StandData)
}
PC1_resid=Standardize(x=PC1,data=Roots)
PC2_resid=Standardize(x=PC2,data=Roots)
PC3_resid=Standardize(x=PC1,data=Roots)
PC4_resid=Standardize(x=PC1,data=Roots)
PC1.distR=dist(PC1_resid)
PC2.distR=dist(PC2_resid)
PC3.distR=dist(PC3_resid)
PC4.distR=dist(PC4_resid)
OTU_pc1_st = mantel(Bray,PC1.distR, method = "spearman", permutations = 9999, na.rm = TRUE)
OTU_pc2_st = mantel(Bray,PC2.distR, method = "spearman", permutations = 9999, na.rm = TRUE)
OTU_pc3_st = mantel(Bray,PC3.distR, method = "spearman", permutations = 9999, na.rm = TRUE)
OTU_pc4_st = mantel(Bray,PC4.distR, method = "spearman", permutations = 9999, na.rm = TRUE)
# RE RUN WITHIN I. PURP ONLY
# Pull out Root traits of interest and save these to the Sampled data frame
SampledRoots=merge(RootAlphaObs,sampledf)
SampledRootsIp=subset(SampledRoots,Species=="Ip")
OTU_table=OTU_table[row.names(OTU_table)%in%SampledRootsIp$Sample_ID,]
OTU=OTU_table
Roots=SampledRootsIp
# Calculate root architecture distances with euclidean distance
PC2=Roots$PC2 # isolate PC2, i.e. root architecture
PC2.dist=dist(PC2)
# Calculate Bray distance matrix for OTU table
Bray=vegdist(OTU,method="bray")
# OTU Bray vs Root architecture
OTU_pc2 = mantel(Bray, PC2.dist, method = "spearman", permutations = 9999, na.rm = TRUE)
# Marginally significant--very low r value
# Mantel statistic r: 0.06836
# Significance: 0.07
# Reapat for root topology, size and morphology
PC1=Roots$PC1 # isolate
PC1.dist=dist(PC1)
PC3=Roots$PC3 # isolate
PC3.dist=dist(PC3)
PC4=Roots$PC1 # isolate
PC4.dist=dist(PC4)
# Examine overall distances in root system; i.e. use all PCs in distance calculation
PCall=Roots[grep("PC",names(Roots))]
PC.dist=dist(PCall)
OTU_pc = mantel(Bray, PC.dist, method = "spearman", permutations = 9999, na.rm = TRUE)
###             examine mantel test using observed values of roots ###
OTU_pc1 = mantel(Bray,PC1.dist, method = "spearman", permutations = 9999, na.rm = TRUE)
# OTU_pc2 = mantel(Bray,PC2.dist, method = "spearman", permutations = 9999, na.rm = TRUE)
OTU_pc3 = mantel(Bray,PC3.dist, method = "spearman", permutations = 9999, na.rm = TRUE)
OTU_pc4 = mantel(Bray,PC4.dist, method = "spearman", permutations = 9999, na.rm = TRUE)
# Repeat but standardize for Block
Standardize=function(x,data){
StandData=residuals(lm(x~Block,data))
return(StandData)
}
PC1_resid=Standardize(x=PC1,data=Roots)
PC2_resid=Standardize(x=PC2,data=Roots)
PC3_resid=Standardize(x=PC1,data=Roots)
PC4_resid=Standardize(x=PC1,data=Roots)
PC1.distR=dist(PC1_resid)
PC2.distR=dist(PC2_resid)
PC3.distR=dist(PC3_resid)
PC4.distR=dist(PC4_resid)
OTU_pc1_st = mantel(Bray,PC1.distR, method = "spearman", permutations = 9999, na.rm = TRUE)
OTU_pc2_st = mantel(Bray,PC2.distR, method = "spearman", permutations = 9999, na.rm = TRUE)
OTU_pc3_st = mantel(Bray,PC3.distR, method = "spearman", permutations = 9999, na.rm = TRUE)
OTU_pc4_st = mantel(Bray,PC4.distR, method = "spearman", permutations = 9999, na.rm = TRUE)
# Chunk 35
#  Here we use the Family mean values of root traits---this would indicate evidence for 'phenotypic selection'
# Load matrix Bray distances of OTU abundance
OTU_table=t(otu_table(physeq1)) # Write out OTU table
# Pull out Root traits of interest and save these to the Sampled data frame
SampledFit=merge(FitAveraged,sampledf,by=c("TRT","ML","Block"))
# Subset per treatment
SampledFitComp=SampledFit%>%filter(TRT=="Inter")
OTU_table_Comp=OTU_table[row.names(OTU_table)%in%SampledFitComp$Sample_ID,]
SampledFitAlone=SampledFit%>%filter(TRT!="Inter")
OTU_table_Alone=OTU_table[row.names(OTU_table)%in%SampledFitAlone$Sample_ID,]
OTU_Comp=OTU_table_Comp
Fit_Comp=SampledFitComp
OTU_Alone=OTU_table_Alone
Fit_Alone=SampledFitAlone
# Calculate fitness distances w euclidean distance
Fit.distComp=dist(Fit_Comp$RelativeFitness)
Fit.distAlone=dist(Fit_Alone$RelativeFitness)
# Calculate Bray distance matrix for OTU table
BrayComp=vegdist(OTU_Comp,method="bray")
BrayAlone=vegdist(OTU_Alone,method="bray")
# OTU Bray vs Fitness per treatment
OTU_Fit_Comp = mantel(BrayComp, Fit.distComp, method = "spearman", permutations = 9999, na.rm = TRUE)
OTU_Fit_Alone = mantel(BrayAlone, Fit.distAlone, method = "spearman", permutations = 9999, na.rm = TRUE)
# Run partial mantel test and control for plant size--i.e., plant size distance matrix
# First  average combined fitness and leaf data
Fit2Average=FitnessPurp2%>%
filter(Species=="Ip")%>%
group_by(ML,Block,Trt)%>%
summarise("RelativeFitAv"=mean(RelativeFit,rm.na=T),"LeafAv"=mean(Leaf.Number,rm.na=T))
Fit2Average$TRT=Fit2Average$Trt
# Pull out Root traits of interest and save these to the Sampled data frame
SampledFit=merge(Fit2Average,sampledf,by=c("TRT","ML","Block"))
# Subset per treatment
SampledFitComp=SampledFit%>%filter(TRT=="Inter")
OTU_table_Comp=OTU_table[row.names(OTU_table)%in%SampledFitComp$Sample_ID,]
SampledFitAlone=SampledFit%>%filter(TRT!="Inter")
OTU_table_Alone=OTU_table[row.names(OTU_table)%in%SampledFitAlone$Sample_ID,]
OTU_Comp=OTU_table_Comp
Fit_Comp=SampledFitComp
Fit_Alone=SampledFitAlone
OTU_Alone=OTU_table_Alone
# Remove NAS
Remove=which(Fit_Alone$LeafAv%in%NA)
# Calculate fitness distances w euclidean distance
Fit.distComp=dist(Fit_Comp$RelativeFitAv)
Fit.distAlone=dist(Fit_Alone[-Remove,"RelativeFitAv"])
# Calculate size distances w euclidean distance
Leaf.distComp=dist(Fit_Comp$LeafAv)
Leaf.distAlone=dist(Fit_Alone[-Remove,"LeafAv"])
# Calculate Bray distance matrix for OTU table
BrayComp=vegdist(OTU_Comp,method="bray")
BrayAlone=vegdist(OTU_Alone[-Remove,],method="bray")
# OTU Bray vs Fitness per treatment
OTU_Fit_Comp_Par = mantel.partial(BrayComp, Fit.distComp, Leaf.distComp, method = "spearman", permutations = 9999, na.rm = TRUE)
OTU_Fit_Alone_Par = mantel.partial(BrayAlone, Fit.distAlone,Leaf.distAlone, method = "spearman", permutations = 9999, na.rm = TRUE)
head(    BrayComp)
BrayComp[1:9,]
BrayComp[1:9]
OTU_Fit_Comp_Par
anova(lm(RelativeFitness~PC2*sim*TRT*Block,RootFitAlpha))
anova(lm(RelativeFitness~PC2*even*TRT*Block,RootFitAlpha))
summary(lm(RelativeFitness~PC2*even*Block,RootFitAlpha%>%filter(TRT=="Alone")))
summary(lm(RelativeFitness~PC2*even*Block,RootFitAlpha%>%filter(TRT!="Alone")))
RootAlphaPurp=droplevels(RootAlphaObs%>%filter(Species=="Ip"))
RootAlphaPurp$Comp=sub(".*\\-","",RootAlphaPurp$Combos)
SimpPC1=lm(sim~PC1+Comp+TRT+Block,RootAlphaPurp)
summary(SimpPC1)
anova(SimpPC1) # Significant Competitor effect
SimpInvPC1=lm(InvSimp~PC1+Comp+TRT+Block,RootAlphaPurp)
anova(SimpInvPC1) # Significant PC1 effect only, no Comp or Comp by PC1 effect
RichPC1=lm(rich~PC1+Comp+TRT+Block,RootAlphaPurp)
anova(RichPC1) # Marginal Competitor effect
anova(lm(rich~PC1+Comp+TRT+Block,RootAlphaPurp))
EvenPC1=lm(even~PC1+Comp+TRT+Block,RootAlphaPurp)
anova(EvenPC1)
SimpPC2=lm(sim~PC2+Comp+TRT+Block,RootAlphaPurp)
anova(SimpPC2) # NS
# ANCOVA
anova(lm(sim~PC2*TRT+Block,RootAlphaPurp)) # NS
SimpInvPC2=lm(InvSimp~PC2+Comp+TRT+Block,RootAlphaPurp)
anova(SimpInvPC2) # NS
RichPC2=lm(rich~PC2+Comp+TRT+Block,RootAlphaPurp)
anova(RichPC2) # Significant coefficient SUPER small effect size
EvenPC2=lm(even~PC2+Comp+TRT+Block,RootAlphaPurp)
anova(EvenPC2) # Significant mean Evenness effect--should Check this out it is suspect
### PC3
SimpPC3=lm(sim~PC2+Comp+TRT+Block,RootAlphaPurp)
anova(SimpPC3) # NS
SimpInvPC1=lm(InvSimp~PC1+PC2+PC3+PC4+Comp+TRT+Block,RootAlphaPurp)
anova(SimpInvPC1) # Significant PC1 effect only, no Comp or Comp by PC1 effect
SimpInvPC1=lm(InvSimp~Comp+TRT+Block,RootAlphaPurp)
anova(SimpInvPC1) # Significant PC1 effect only, no Comp or Comp by PC1 effect
alpha.purp<-alpha%>%filter(Species=="Ip")
alpha.purp$Comp<-as.factor(alpha.purp$Comp)
aov.Richness = lm(rich~Block*Comp,alpha.purp%>%filter(TRT=="Inter"))
aov.simpsonInv = lm(InvSimp~Block*Comp,alpha.purp%>%filter(TRT=="Inter"))
aov.simpson = lm(sim~Block*Comp,alpha.purp%>%filter(TRT=="Inter"))
aov.evenness = lm(even~Block*Comp,alpha.purp%>%filter(TRT=="Inter"))
aov.shannon = lm(shan~Block*Comp,alpha.purp%>%filter(TRT=="Inter"))
#Call for the summary of that ANOVA, which will include P-values
anova(aov.Richness)
anova(aov.simpsonInv)
anova(aov.simpson)
anova(aov.evenness)
anova(aov.shannon)
aov.Richness = lm(rich~Block*Comp*Trt,alpha.purp)
aov.Richness = lm(rich~Block*Comp*TRT,alpha.purp)
alpha.purp<-alpha%>%filter(Species=="Ip")
alpha.purp$Comp<-as.factor(alpha.purp$Comp)
aov.Richness = lm(rich~Block*Comp*TRT,alpha.purp)
aov.simpsonInv = lm(InvSimp~Block*Comp*TRT,alpha.purp)
aov.simpson = lm(sim~Block*Comp*TRT,alpha.purp)
aov.evenness = lm(even~Block*Comp*TRT,alpha.purp)
aov.shannon = lm(shan~Block*Comp*TRT,alpha.purp)
anova(aov.Richness)
anova(aov.simpsonInv)
anova(aov.simpson)
anova(aov.evenness)
anova(aov.shannon)
anova(lm(RelativeFitness~PC3*sim*TRT*Block,RootFitAlpha))
anova(lm(RelativeFitness~PC1*InvSimp*TRT*Block,RootFitAlpha))
anova(lm(RelativeFitness~PC1*sim*TRT*Block,RootFitAlpha))
summary(lm(RelativeFitness~PC4*InvSimp+Block,RootFitAlpha%>%filter(TRT!="Alone")))
summary(lm(RelativeFitness~PC4*Simp*Block,RootFitAlpha))
summary(lm(RelativeFitness~PC4*sim*TRT*Block,RootFitAlpha))
anova(lm(RelativeFitness~PC4*sim*TRT*Block,RootFitAlpha))
anova(lm(RelativeFitness~PC2*InvSimp*TRT*Block,RootFitAlpha))
anova(lm(RelativeFitness~PC4*InvSimp*TRT*Block,RootFitAlpha))
anova(lm(RelativeFitness~PC1*InvSimp*TRT*Block,RootFitAlpha))
anova(lm(RelativeFitness~PC1*InvSimp*TRT*Block,RootFitAlpha))
InvSimpPC3Comp=lm(RelativeFitness~PC3*InvSimp+Block,RootFitAlpha%>%filter(TRT!="Alone"))
summary(InvSimpPC3Comp)
anova(lm(RelativeFitness~PC3*InvSimp*TRT*Block,RootFitAlpha))
anova(lm(RelativeFitness~PC1*even*TRT*Block,RootFitAlpha))
anova(lm(RelativeFitness~PC2*even*TRT*Block,RootFitAlpha))
anova(lm(RelativeFitness~PC3*even*TRT*Block,RootFitAlpha))
anova(lm(RelativeFitness~PC4*even*TRT*Block,RootFitAlpha))
anova(lm(RelativeFitness~PC2*rich*TRT*Block,RootFitAlpha)) # Interesting results!  effect
richPC1=lm(RelativeFitness~PC1*rich*Trt*Block,RootFitAlpha)
anova(richPC1)
anova(lm(RelativeFitness~PC3*rich*TRT*Block,RootFitAlpha)) # Significant richness effect
anova(lm(RelativeFitness~PC4*rich*TRT*Block,RootFitAlpha))
x1 <- RootFitAlpha$PC3
x2 <- RootFitAlpha$sim
y <- RootFitAlpha$RelativeFitness
dataset = cbind.data.frame(x1,x2,y)
scatterplot3d(x1,x2,y)
library(scatterplot3d) # This library will allow us to draw 3d plot
scatterplot3d(x1,x2,y)
my.lm<- lm(RelativeFitness~Trt*Block*PC3*sim,RootFitAlpha)
plot3d <- scatterplot3d(x1,x2,y,
angle=55, scale.y=0.7, pch=16, color ="red", main ="Regression Plane")
my.lm<- lm(RelativeFitness~Trt*Block*PC3*sim,RootFitAlpha)
plot3d$plane3d(my.lm, lty.box = "solid")
plot3d$points3d(x1,x2,y_hat,col="blue", type="h", pch=16)
predict(my.lm)
length(predict(my.lm))
length(y)
y_hat=predict(my.lm)
plot3d$points3d(x1,x2,y_hat,col="blue", type="h", pch=16)
plot3d$plane3d(my.lm, lty.box = "solid")
my.lm<- lm(y~x1+x2)
plot3d$plane3d(my.lm, lty.box = "solid")
RootFitAlphaAlone=RootFitAlpha%>%filter(TRT=="Alone")
RootFitAlphaComp=RootFitAlpha%>%filter(TRT!="Alone")
# Input data
x <- RootFitAlphaAlone$PC3
y <- RootFitAlphaAlone$sim
z <- RootFitAlphaAlone$RelativeFitness
fit <- lm(z ~ x + y)
# predict values on regular xy grid
grid.lines = 26
x.pred <- seq(min(x), max(x), length.out = grid.lines)
y.pred <- seq(min(y), max(y), length.out = grid.lines)
xy <- expand.grid( x = x.pred, y = y.pred)
z.pred <- matrix(predict(fit, newdata = xy),
nrow = grid.lines, ncol = grid.lines)
# fitted points for droplines to surface
fitpoints <- predict(fit)
# scatter plot with regression plane
scatter3D(x, y, z, pch = 18, cex = 2,
theta = 20, phi = 20, ticktype = "detailed",
xlab = "wt", ylab = "disp", zlab = "mpg",
surf = list(x = x.pred, y = y.pred, z = z.pred,
facets = NA, fit = fitpoints), main = "mtcars")
library("plot3D")
scatter3D(x, y, z, pch = 18, cex = 2,
theta = 20, phi = 20, ticktype = "detailed",
xlab = "Root Size", ylab = "Simpson Diversity", zlab = "Relative Fitness",
surf = list(x = x.pred, y = y.pred, z = z.pred,
facets = NA, fit = fitpoints), main = "Absence of Competition")
scatter3D(x, y, z, pch = 18, cex = 2,
theta =45, phi = 20,
xlab = "Root Size", ylab = "Simpson Diversity", zlab = "Relative Fitness",
surf = list(x = x.pred, y = y.pred, z = z.pred,
facets = NA, fit = fitpoints), main = "Absence of Competition")
scatter3D(x, y, z, pch = 18, cex = 2,
theta =45, phi = 20, colvar = NULL, col = "blue",
xlab = "Root Size", ylab = "Simpson Diversity", zlab = "Relative Fitness",
surf = list(x = x.pred, y = y.pred, z = z.pred,
facets = NA, fit = fitpoints), main = "Absence of Competition")
# scatter plot with regression plane
scatter3D(x, y, z, pch = 18, cex = 2,
theta =45, phi = 20, colvar = NULL, col = "red",
xlab = "Root Size", ylab = "Simpson Diversity", zlab = "Relative Fitness",
surf = list(x = x.pred, y = y.pred, z = z.pred,
facets = NA, fit = fitpoints), main = "Absence of Competition")
# scatter plot with regression plane
scatter3D(x, y, z, pch = 18, cex = 2,
theta =45, phi = 20, colvar = NULL, col = "blue",
xlab = "Root Size", ylab = "Simpson Diversity", zlab = "Relative Fitness",
surf = list(x = x.pred, y = y.pred, z = z.pred,
facets = NA, fit = fitpoints), main = "Absence of Competition")
scatter3D(x, y, z, pch = 18, cex = 2,
theta =45, phi = 30, colvar = NULL, col = "blue",
xlab = "Root Size", ylab = "Simpson Diversity", zlab = "Relative Fitness",
surf = list(x = x.pred, y = y.pred, z = z.pred,
facets = NA, fit = fitpoints), main = "Absence of Competition")
scatter3D(x, y, z, pch = 18, cex = 2,
theta =45, phi = 15, colvar = NULL, col = "blue",
xlab = "Root Size", ylab = "Simpson Diversity", zlab = "Relative Fitness",
surf = list(x = x.pred, y = y.pred, z = z.pred,
facets = NA, fit = fitpoints), main = "Absence of Competition")
scatter3D(x, y, z, pch = 18, cex = 2,
theta =45, phi = 10, colvar = NULL, col = "blue",
xlab = "Root Size", ylab = "Simpson Diversity", zlab = "Relative Fitness",
surf = list(x = x.pred, y = y.pred, z = z.pred,
facets = NA, fit = fitpoints), main = "Absence of Competition")
scatter3D(x, y, z, pch = 18, cex = 2,
theta =90, phi = 10, colvar = NULL, col = "blue",
xlab = "Root Size", ylab = "Simpson Diversity", zlab = "Relative Fitness",
surf = list(x = x.pred, y = y.pred, z = z.pred,
facets = NA, fit = fitpoints), main = "Absence of Competition")
scatter3D(x, y, z, pch = 18, cex = 2,
theta =135, phi = 10, colvar = NULL, col = "blue",
xlab = "Root Size", ylab = "Simpson Diversity", zlab = "Relative Fitness",
surf = list(x = x.pred, y = y.pred, z = z.pred,
facets = NA, fit = fitpoints), main = "Absence of Competition")
x <- RootFitAlphaComp$PC3
y <- RootFitAlphaComp$sim
z <- RootFitAlphaComp$RelativeFitness
# Compute the linear regression (z = ax + by + d)
fit <- lm(z ~ x + y)
# predict values on regular xy grid
grid.lines = 26
x.pred <- seq(min(x), max(x), length.out = grid.lines)
y.pred <- seq(min(y), max(y), length.out = grid.lines)
xy <- expand.grid( x = x.pred, y = y.pred)
z.pred <- matrix(predict(fit, newdata = xy),
nrow = grid.lines, ncol = grid.lines)
# fitted points for droplines to surface
fitpoints <- predict(fit)
# scatter plot with regression plane
scatter3D(x, y, z, pch = 18, cex = 2,
theta =135, phi = 10, colvar = NULL, col = "blue",
xlab = "Root Size", ylab = "Simpson Diversity", zlab = "Relative Fitness",
surf = list(x = x.pred, y = y.pred, z = z.pred,
facets = NA, fit = fitpoints), main = "Absence of Competition")
scatter3D(x, y, z, pch = 18, cex = 2,
theta =45, phi = 10, colvar = NULL, col = "blue",
xlab = "Root Size", ylab = "Simpson Diversity", zlab = "Relative Fitness",
surf = list(x = x.pred, y = y.pred, z = z.pred,
facets = NA, fit = fitpoints), main = "Presence of Competition")
adonis(physeq.bray3 ~ Species+Block+ML, data = sampledf%>%filter(TRT=="Inter"))
b = betadisper(physeq.bray3,( sampledf%>%filter(TRT=="Inter"))$Species)
p <- permutest(b)
p$tab
p <- permutest(b)
b
adonis(physeq.bray3 ~ Species+Block*ML, data = sampledf%>%filter(TRT=="Inter"))
b = betadisper(physeq.bray3,( sampledf%>%filter(TRT=="Inter"))$Species)
adonis(physeq.bray2 ~ TRT+Block*ML, data = sampledf%>%filter(Species=="Ip")) # No treatment effect on bray distances
adonis(physeq.bray2 ~ Block*ML, data = sampledf%>%filter(Species!="Ip")) # No treatment effect on bray distances
physeq.hed=subset_samples(physeq.scale, Species != "Ip")
physeq.bray2b <- phyloseq::distance(physeq = physeq.hed, method = "bray") # within Ipurp
adonis(physeq.bray2b ~ Block*ML, data = sampledf%>%filter(Species!="Ip")) # No treatment effect on bray distances
adonis(physeq.bray2 ~ TRT+Block*ML+Comp, data = sampledf%>%filter(Species=="Ip")) # No treatment effect on bray distances
adonis(physeq.bray2b ~ Block*ML+Comp, data = sampledf%>%filter(Species!="Ip")) # No treatment effect on bray distances
adonis(physeq.bray3 ~ Species+Block*Comp, data = sampledf%>%filter(TRT=="Inter"))
adonis(physeq.bray3 ~ Species+Block*Comp+ML, data = sampledf%>%filter(TRT=="Inter"))
p3
ggplot(physeq.pcoa.df, aes(Axis.1, Axis.2, color = TRT,fill = TRT)) +
xlab(bray_axis1) +
ylab(bray_axis2) +
geom_point(alpha=0.9) +
theme_classic() +
scale_fill_manual(values = c("#00B050","grey"),"Treatment", labels = c("Alone", "Competition"))+
scale_color_manual(values = c("#00B050","grey"),"Treatment", labels = c("Alone", "Competition"))+
stat_ellipse(geom = "polygon", alpha = 1/6, aes(fill =TRT))+
Tx+
theme(axis.text.x = element_text(angle=45),axis.text=element_text(color="black",size=15,vjust = 0.5,hjust=1))
#  scale_fill_discrete(name = "Treatment", labels = c("Alone", "Competition"))+
# scale_color_discrete(name = "Treatment", labels = c("Alone", "Competition"))
ggplot(physeq.pcoa.df, aes(Axis.3, Axis.4, color = Species,fill = Species)) +
xlab("") +
ylab(bray_axis4) +
geom_point(alpha=0.9) +
theme_classic()+
scale_fill_manual(values = GreenBlue,"Species", labels = c("I. hederacea", "I. purpurea"))+
scale_color_manual(values = GreenBlue,"Species", labels = c("I. hederacea", "I. purpurea"))+
stat_ellipse(geom = "polygon", alpha = 1/6, aes(fill =Species))+
Tx
ggplot(physeq.pcoa.df, aes(Axis.3, Axis.4, color = Species,fill = Species)) +
xlab("") +
ylab(bray_axis4) +
geom_point(alpha=0.9) +
theme_classic()+
scale_fill_manual(values = GreenBlue,"Species", labels = c("I. hederacea", "I. purpurea"))+
scale_color_manual(values = GreenBlue,"Species", labels = c("I. hederacea", "I. purpurea"))+
stat_ellipse(geom = "polygon", alpha = 1/6, aes(fill =Species))+
facet_grid(~Block)+
Tx
ggplot(physeq.pcoa.df, aes(Axis.3, Axis.4, color = Species,fill = Comp)) +
xlab("") +
ylab(bray_axis4) +
geom_point(alpha=0.9) +
theme_classic()+
scale_fill_manual(values = GreenBlue,"Species", labels = c("I. hederacea", "I. purpurea"))+
scale_color_manual(values = GreenBlue,"Species", labels = c("I. hederacea", "I. purpurea"))+
stat_ellipse(geom = "polygon", alpha = 1/6, aes(fill =Species))+
Tx
ggplot(physeq.pcoa.df, aes(Axis.3, Axis.4, color = Comp,fill = Comp)) +
xlab("") +
ylab(bray_axis4) +
geom_point(alpha=0.9) +
theme_classic()+
#scale_fill_manual(values = GreenBlue,"Species", labels = c("I. hederacea", "I. purpurea"))+
#scale_color_manual(values = GreenBlue,"Species", labels = c("I. hederacea", "I. purpurea"))+
stat_ellipse(geom = "polygon", alpha = 1/6, aes(fill =Species))+
Tx
head(physeq.pcoa.df)
ggplot(physeq.pcoa.df, aes(Axis.3, Axis.4, color = ML,fill = ML)) +
xlab("") +
ylab(bray_axis4) +
geom_point(alpha=0.9) +
theme_classic()+
#scale_fill_manual(values = GreenBlue,"Species", labels = c("I. hederacea", "I. purpurea"))+
#scale_color_manual(values = GreenBlue,"Species", labels = c("I. hederacea", "I. purpurea"))+
stat_ellipse(geom = "polygon", alpha = 1/6, aes(fill =Species))+
Tx
ggplot(physeq.pcoa.df, aes(Axis.3, Axis.4, color = Species,fill = Species)) +
xlab("") +
ylab(bray_axis4) +
geom_point(alpha=0.9) +
theme_classic()+
scale_fill_manual(values = GreenBlue,"Species", labels = c("I. hederacea", "I. purpurea"))+
scale_color_manual(values = GreenBlue,"Species", labels = c("I. hederacea", "I. purpurea"))+
stat_ellipse(geom = "polygon", alpha = 1/6, aes(fill =Species))+
Tx
adonis(physeq.bray3 ~ Species+Block*Comp+Block*ML, data = sampledf%>%filter(TRT=="Inter"))
adonis(physeq.bray3 ~ Species+Block*Comp+Block*ML, data = sampledf%>%filter(TRT=="Inter"))
adonis(physeq.bray3 ~ Species+Block*ML, data = sampledf%>%filter(TRT=="Inter"))
